<!DOCTYPE html>
<html lang="ce">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hayahayao.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="さおりのBlog">
<meta property="og:url" content="https://hayahayao.github.io/index.html">
<meta property="og:site_name" content="さおりのBlog">
<meta property="og:locale">
<meta property="article:author" content="hayahayao">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hayahayao.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'ce'
  };
</script>

  <title>さおりのBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">さおりのBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">燃えて散った花となれ。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2022/04/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/12/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">前端性能优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-12 21:22:00" itemprop="dateCreated datePublished" datetime="2022-04-12T21:22:00+08:00">2022-04-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:33:51" itemprop="dateModified" datetime="2023-08-23T01:33:51+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><h3 id="FCP"><a href="#FCP" class="headerlink" title="FCP"></a>FCP</h3><h3 id="LCP"><a href="#LCP" class="headerlink" title="LCP"></a>LCP</h3><h3 id="产品的关键路径"><a href="#产品的关键路径" class="headerlink" title="产品的关键路径"></a>产品的关键路径</h3><p>自行埋点</p>
<h2 id="如何分析性能"><a href="#如何分析性能" class="headerlink" title="如何分析性能"></a>如何分析性能</h2><h3 id="Performance-Lighthouse"><a href="#Performance-Lighthouse" class="headerlink" title="Performance Lighthouse"></a>Performance Lighthouse</h3><h3 id="全链路埋点"><a href="#全链路埋点" class="headerlink" title="全链路埋点"></a>全链路埋点</h3><p>分析过后，希望能够得到一个加载的流程图，标明每个步骤的用时</p>
<p>然后就可以针对性地解决用时长的那些步骤</p>
<p>一些常见的用时长的步骤：</p>
<ul>
<li>静态资源加载&amp;解析执行</li>
<li>图片的加载</li>
<li>接口调用</li>
</ul>
<h2 id="常见的性能优化手段"><a href="#常见的性能优化手段" class="headerlink" title="常见的性能优化手段"></a>常见的性能优化手段</h2><h3 id="减小资源体积"><a href="#减小资源体积" class="headerlink" title="减小资源体积"></a>减小资源体积</h3><h4 id="js-css资源"><a href="#js-css资源" class="headerlink" title="js&#x2F;css资源"></a>js&#x2F;css资源</h4><ul>
<li>分包，提取公共代码</li>
<li>异步（动态）组件，非首屏需要的代码不加载</li>
<li>babel的精细化配置，仿vue-cli的modern mode</li>
</ul>
<p>分析工具：<br>webpack analyze plugin</p>
<h4 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h4><ul>
<li>图片压缩<ul>
<li>上传时压缩</li>
<li>与设计达成图片体积限制共识</li>
</ul>
</li>
<li>图片转webp格式<ul>
<li>对于固定的代码如webp检测，如何自动注入？</li>
<li>postcss，自动生成对应的css？</li>
</ul>
</li>
</ul>
<h3 id="更好地利用缓存"><a href="#更好地利用缓存" class="headerlink" title="更好地利用缓存"></a>更好地利用缓存</h3><ul>
<li>合理分包，划分出“经常改动的代码”“基本不会变的代码”，配合contenthash和资源的ETag，实现每次部署后只有改动的那些代码对应的文件变了，而其他文件都还可以用缓存的</li>
<li>基于DLL实现依赖共享，如vue等基础框架包 团队公共sdk包等<ul>
<li>如何合理拆分DLL</li>
<li>如何进行DLL的版本控制</li>
</ul>
</li>
<li>客户端的离线包机制</li>
</ul>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><ul>
<li>preconnect</li>
<li>gzip压缩</li>
<li>http2</li>
</ul>
<h3 id="让用户“觉得快”"><a href="#让用户“觉得快”" class="headerlink" title="让用户“觉得快”"></a>让用户“觉得快”</h3><ul>
<li>把Loading放在html模板中<ul>
<li>如何避免手写html模板？如何维护跨端项目的两份代码？</li>
</ul>
</li>
<li>加载完首屏之后对其他可能用到的资源进行预加载，包括图片&#x2F;js&#x2F;css等<ul>
<li>配合异步组件，如何自动化这个过程？</li>
</ul>
</li>
</ul>
<p>这部分如何衡量收益</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%86%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%86%E5%88%AB/" class="post-title-link" itemprop="url">浏览器识别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-11-12 17:47:00" itemprop="dateCreated datePublished" datetime="2020-11-12T17:47:00+08:00">2020-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:34:39" itemprop="dateModified" datetime="2023-08-23T01:34:39+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="浏览器识别"><a href="#浏览器识别" class="headerlink" title="浏览器识别"></a>浏览器识别</h1><h2 id="Javascript-引擎-浏览器引擎"><a href="#Javascript-引擎-浏览器引擎" class="headerlink" title="Javascript 引擎 &amp; 浏览器引擎"></a>Javascript 引擎 &amp; 浏览器引擎</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/JavaScript_engine">Javascript 引擎</a></p>
<ul>
<li>V8: chrome, chromium, edge</li>
<li>SpiderMonkey: firefox</li>
<li>JavaScriptCore: safari, other webkit-based browser</li>
<li>chakra: ie</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Browser_engine">浏览器引擎</a></p>
<p>layout&#x2F;rendering 引擎 + js 引擎</p>
<ul>
<li>gecko: firefox</li>
<li>webkit: safari, 以前的 chrome</li>
<li>blink: 现在的 chrome</li>
<li>trident: ie</li>
<li>presto: opera</li>
</ul>
<p>通过全局对象 <code>navigator.userAgent</code> 可以获得关于浏览器引擎的信息</p>
<h2 id="套壳浏览器"><a href="#套壳浏览器" class="headerlink" title="套壳浏览器"></a>套壳浏览器</h2><ul>
<li>国内浏览器基本都是所谓套壳浏览器，即在 chrome &amp; ie 基础上加点东西，一般极速模式对应 chrome，兼容模式对应 ie</li>
<li>但是套壳浏览器可能用的不是最新版内核，或者某些 api 表现不一样..</li>
<li>一般套壳浏览器会在 <code>userAgent</code> 上加上自己的厂商标识，不过目前发现 360 没有（后面给出一种暂时可用的 hack）</li>
<li>ps. 调试过程中发现 360 还可以换 ie11&#x2F;10&#x2F;9&#x2F;8… 的内核，用来测试兼容性还是挺好用的</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>发现 360 的 <code>navigator.mimeTypes</code> 与 chrome 有很大不同，其中有一些项带着 360 标识，应该别的浏览器不会有吧..</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mime = navigator.<span class="property">mimeTypes</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> mime) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/360/</span>.<span class="title function_">test</span>(mime[key].<span class="property">type</span>)) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;360&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>注意低版本浏览器可能不支持 es6 甚至 es5 语法</li>
<li>如果整合进项目中，最好将这部分与其他部分分离，不然为了兼容低版本和 ie 需要 webpack 加很多 babel 配置，而且可能还不行…</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/09/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/16/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD%E6%96%B9%E6%A1%88/" class="post-title-link" itemprop="url">前端大文件下载方案</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-16 11:26:00" itemprop="dateCreated datePublished" datetime="2020-09-16T11:26:00+08:00">2020-09-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:34:11" itemprop="dateModified" datetime="2023-08-23T01:34:11+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="前端大文件下载方案"><a href="#前端大文件下载方案" class="headerlink" title="前端大文件下载方案"></a>前端大文件下载方案</h1><blockquote>
<p>tags: </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Streams_API">Streams API</a> </li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/jimmywarting/StreamSaver.js">StreamSaver.js</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Stuk/jszip">JSZip</a></li>
</ul>
</blockquote>
<p>在业务中遇到需要用户下载一个很巨大的 zip 包的场景，内容通常是一堆很小的（图片）文件打包到一起。传统的下载方案是直接修改 <code>window.location.href=后端提供的下载链接</code>，之后后端一边去下载要打包的文件，一边把打包好的东西写入这个链接。</p>
<p>存在的问题是，如果文件很大，这个链接需要一直保持，相当于这个接口一直开着没有结束（运维同学很不开心）；而且一旦中间出了什么问题，已经下载的东西也全部废了，下次还要重新开始（可以通过设置 http range 头等方法实现断点续传）。</p>
<p>那么，反正后端也没有存这个大文件，也是现用现生成的，可不可以把这个工作转移到前端？如果把请求一堆小文件的工作转移到浏览器，那就绕开了下载接口的时间限制，而且我们知道哪些文件已经下载了，是不是也可以通过一些操作保留住已经下载的文件？</p>
<h2 id="JSZip"><a href="#JSZip" class="headerlink" title="JSZip"></a>JSZip</h2><p>在知道 Streams API 这种高级玩意之前，我一直以为浏览器中的 js 代码是不能做流操作的，也就是不能一边下一边往本地写。那么一个最直接的想法就是把文件都下到内存中，之后调用 <a target="_blank" rel="noopener" href="https://github.com/Stuk/jszip">JSZip</a> 统一打包，再调用 <a target="_blank" rel="noopener" href="https://github.com/eligrey/FileSaver.js/">FileSaver.js</a> 触发保存操作。文件数据一直是以 blob 方式传递的，简单的代码示意如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; saveAs &#125; <span class="keyword">from</span> <span class="string">&#x27;file-saver&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">JSZip</span> <span class="keyword">from</span> <span class="string">&#x27;jszip&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urls = [xxx] <span class="comment">// 一堆需要下载的文件 url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ZIP</span> = <span class="keyword">new</span> <span class="title function_">JSZIP</span>()</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(urls.<span class="title function_">map</span>(<span class="function">(<span class="params">url, index</span>) =&gt;</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(url).<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">            zip.<span class="title function_">file</span>(url, response.<span class="title function_">blob</span>()) <span class="comment">// blob 哦</span></span><br><span class="line">            <span class="title function_">resolve</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;))).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    zip.<span class="title function_">generateAsync</span>(&#123; <span class="attr">type</span>: <span class="string">&#x27;blob&#x27;</span> &#125;).<span class="title function_">then</span>(<span class="function"><span class="params">content</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">saveAs</span>(content, <span class="string">&#x27;hello.zip&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>很容易想象，这种方式对内存消耗非常大，而且随着文件数量的增长，打包 zip 这个过程会越来越慢，时间当然也不是线性增长那么简单。实际测试结果也如此（不过实际测试，能处理的文件大小超出了我的想象，几个 G 都不是问题，就是慢而已）。</p>
<h2 id="StreamSaver-js"><a href="#StreamSaver-js" class="headerlink" title="StreamSaver.js"></a>StreamSaver.js</h2><p>前置阅读：<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904029244358670">从 Fetch 到 Streams —— 以流的角度处理网络请求</a></p>
<p>啊，流，完美的解决方案。</p>
<p>有了读写流的能力，还需要解决的一个问题就是如何维持一个持续的通道，保证能够一边在下载，一边把下载的东西写到本地。</p>
<p>啊哈，我们也可以模仿后端，制造一个（不存在的）下载链接，然后用 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API">Service Worker</a> 去拦截对这个链接的请求，持续往这里面写就可以了！</p>
<p>这就是 <a target="_blank" rel="noopener" href="https://github.com/jimmywarting/StreamSaver.js">StreamSaver.js</a> 所做的事情。简单的代码示意如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">StreamSaver</span> <span class="keyword">from</span> <span class="string">&#x27;streamsaver&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ZipStream</span> <span class="keyword">from</span> <span class="string">&#x27;./zip-stream.js&#x27;</span> <span class="comment">// 作者提供的 zip 工具</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> urls = [xxx] <span class="comment">// 一堆需要下载的文件 url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fileStream = <span class="title class_">StreamSaver</span>.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;hello.zip&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> readableZipStream = <span class="keyword">new</span> <span class="title class_">ZipStream</span>(&#123;</span><br><span class="line">    <span class="keyword">async</span> <span class="title function_">pull</span>(<span class="params">control</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> it = url.<span class="title function_">next</span>()</span><br><span class="line">        <span class="keyword">if</span> (it.<span class="property">done</span>) &#123;</span><br><span class="line">            control.<span class="title function_">close</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">            control.<span class="title function_">enqueue</span>(&#123;</span><br><span class="line">                <span class="attr">name</span>: url,</span><br><span class="line">                <span class="attr">stream</span>: <span class="function">() =&gt;</span> response.<span class="property">body</span> <span class="comment">// 这个是 ReadableStream 类型！web 标准万岁！</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">WritableStream</span> &amp;&amp; readableZipStream.<span class="property">pipeTo</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> readableZipStream.<span class="title function_">pipeTo</span>(fileStream).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            that.<span class="property">dialogExportProcess</span> = <span class="literal">false</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>上述的代码实现了每次下载一个文件 -&gt; 向流中写入一个文件这样类似单线程（？）的处理过程，那么能否实现如<a target="_blank" rel="noopener" href="https://juejin.im/post/6844904029244358670">从 Fetch 到 Streams —— 以流的角度处理网络请求</a>这篇中所说，结合 JSZip，在一次 <code>pull</code> 过程中下载好几个，然后用 JSZip 把这好几个文件压成一块流一口气写入呢？</p>
<h3 id="与-JSZip-结合使用？"><a href="#与-JSZip-结合使用？" class="headerlink" title="与 JSZip 结合使用？"></a>与 JSZip 结合使用？</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/23/16f304e310ea9e49?imageslim" alt="与 JSZip 结合使用"></p>
<p>首先，使用文章里描述的 <code>generateInternalStream()</code> 这个方法是行不通的，JSZip 的 <code>StreamHelper</code> API 只是模拟了流的实现，但返回值并不是符合 Stream API 标准的 <code>ReadableStream</code>&#x2F;<code>WritableStream</code> 类型。</p>
<p>不过 blob 总是可行的，如果在 JSZip 里面用 blob 处理，到时候再用 <code>blob.stream()</code> 这种方法转成 <code>ReadableStream</code> 写入流中，似乎听上去不错。不过我在实际操作的过程中遇到的一个问题就是，<code>control.enqueue()</code> 时文件名怎么处理？我试着写成以 &#x2F; 结尾表示我要写入一个文件夹，不过似乎并不能达到预想效果🤔…</p>
<h3 id="mitm-sw-配置"><a href="#mitm-sw-配置" class="headerlink" title="mitm + sw 配置"></a>mitm + sw 配置</h3><p>最后写一下实际使用 StreamSaver 时所需的 sw 配置。</p>
<p>直接跑作者给出的示例代码会发现，运行下载之后页面上会多出两个这样的 iframe</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">hidden</span>=<span class="string">&quot;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://jimmywarting.github.io/StreamSaver.js/mitm.html?version=2.0.0&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">hidden</span>=<span class="string">&quot;&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://jimmywarting.github.io/StreamSaver.js/null/637501/archive.zip&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>emm，第二个看起来像是下载链接的样子（当然是我们制造的，实际打开里面什么都没有），第一个的话打开发现里面有一些 js 代码，似乎是注册了 sw 的样子。</p>
<p>但是这域名，这前缀，都是啥？能不能搞到自己本地？到时候项目上线还带着别人的 github.io 可不行…</p>
<p>来看下作者的解释：</p>
<blockquote>
<p>So the one and only other solution is to do what the server does: Send a stream with Content-Disposition header to tell the browser to save the file. But we don’t have a server or the content isn’t on a server! So the solution is to create a service worker that can intercept request and use respondWith() and act as a server.</p>
<p>But a service workers are only allowed in secure contexts and it requires some effort to put up. Most of the time you are working in the main thread and the service worker are only alive for &lt; 5 minutes before it goes idle.</p>
<p>1.So StreamSaver creates a own man in the middle that installs the service worker in a secure context hosted on github static pages. either from a iframe (in secure context) or a new popup if your page is insecure.</p>
<p>2.Transfer the stream (or DataChannel) over to the service worker using postMessage.</p>
<p>3.And then the worker creates a download link that we then open.</p>
<p>if a “transferable” readable stream was not passed to the service worker then the mitm will also try to keep the service worker alive by pinging it every x second to prevent it from going idle.</p>
</blockquote>
<p>嗯，这个 mitm.html 确实是在完成 service worker 注册的工作。而 service worker 注册有很多限制：（为方便说明，下文中 mitm.html 代表“注册 service worker 的位置“，sw.js 代表“service worker 所在的位置“）</p>
<ul>
<li>只能在 HTTPS&#x2F;localhost 环境下注册（否则报错如 <code>Failed to register a ServiceWorker: An SSL certificate error occurred when fetching the script.</code>）</li>
<li>要注册的 sw.js 文件必须和注册它的 mitm.html 同源（否则报错如 <code>Failed to register ServiceWorker. The origin of the provider scriptURL(&#39;sw.js 所在的域&#39;) does not match the current origin (&#39;mitm.html 所在的域&#39;).</code>）</li>
<li>service worker 的作用域不能超出 sw.js 自己所在位置（否则报错如 <code>Failed to register a ServiceWorker: The path of the provided scope (&#39;mitm.html 所在的路径&#39;) is not under the max scope allowed (&#39;sw.js 所在的路径&#39;). Adjust the scope, move the Service Worker script, or use the Service-Worker-Allowed HTTP header to allow the scope.</code>）</li>
</ul>
<p>所以作者默认把 sw 注册在了他自己的的 github 静态页面上，而如果我们想在自己的域名上注册 sw，就需要注意上面三点限制：</p>
<ul>
<li>https 环境限制：如为 http，可以把网站改成 https 然后手动信任下证书</li>
<li>同源限制：如果不同源，可以采用配置 nginx 代理让它们看上去是同源的</li>
<li>作用域限制：如果不想修改这两个文件的位置，可以通过 nginx 在 sw.js 的 response header 中加入 <code>Service-Worker-Allowed</code> 这个头</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/08/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Javascript%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-Javascript%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">读书笔记-Javascript轻量级函数式编程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-18 11:36:00" itemprop="dateCreated datePublished" datetime="2020-08-18T11:36:00+08:00">2020-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:35:07" itemprop="dateModified" datetime="2023-08-23T01:35:07+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<p>《JavaScript 轻量级函数式编程》读书笔记</p>
<p><a target="_blank" rel="noopener" href="https://github.com/ikcamp/Functional-Light-JS">中文版</a></p>
</blockquote>
<h2 id="函数基础"><a href="#函数基础" class="headerlink" title="函数基础"></a>函数基础</h2><p>实参和形参</p>
<ul>
<li>arguments：输入的值，实参</li>
<li>parameters：函数中的命名变量，形参</li>
</ul>
<p>参数数量</p>
<ul>
<li>Arity：一个函数声明的形参数量<br>可以在运行时通过函数的 <code>length</code> 属性获取</li>
<li>实参数量：<code>arguments.length</code></li>
</ul>
<p>ES6 的 <code>...</code> 操作符</p>
<ul>
<li>在形参列表，它把实参整合；在实参列表，它把实参展开</li>
<li>函数参数用解构数组&#x2F;对象</li>
<li>在函数式编程中，我们希望我们的函数在任何情况下都是一元的（Arity 为 1），可以使用对象解构传参实现</li>
</ul>
<p>解构</p>
<blockquote>
<p>声明性代码通常比命令式代码更干净</p>
</blockquote>
<p>特定多态：通过不同的输入值让一个函数重载拥有不同的行为（在不同的情况下使函数具有不同的输出）。但是这样的设计的维护成本会比较高</p>
<p>函数输出</p>
<ul>
<li>使用函数式编程，每个函数必须明确的 <code>return</code> 一个值</li>
<li>我们经常使用提前 <code>return</code> 来控制代码流，但这会造成难以理解，最好不要用 <code>return</code> 来实现流控制，而是使用明确的表达逻辑的方式</li>
<li>纯函数，避免副作用</li>
</ul>
<p>高阶函数：接受或返回一个甚至多个函数的函数（将其他函数视为值进行操作，一等公民，可作为函数的参数&#x2F;返回值）</p>
<p>闭包</p>
<ul>
<li>当一个函数内部存在另一个函数的作用域时，对当前函数进行操作。当内部函数从外部函数引用变量，这被称作闭包</li>
<li>闭包可以记录并且访问它作用域外的变量，甚至当这个函数在不同的作用域被执行</li>
<li>闭包不仅限于获取变量的原始值：它不仅仅是快照，而是直接链接；你可以更新该值，并在下次访问时获取更新后的值</li>
<li>如果你需要设置两个输入，一个你已经知道，另一个需要后面才能知道，可以使用闭包来记录第一个输入值</li>
<li>同样可以通过闭包来记住函数</li>
</ul>
<p>句法</p>
<ul>
<li>最好给所有函数都命名，避免匿名函数。-&gt; 堆栈轨迹调用；可靠的自我引用和可读性；更好地理解函数的目的&#x2F;设计</li>
<li>箭头函数是词法匿名的，所以具有上述缺点，但语法简洁，能简化&#x2F;优化代码片段中的空间</li>
<li>函数式编程中不要使用 <code>this</code>，因为 <code>this</code> 相当于使用了隐式输入</li>
</ul>
<h2 id="管理函数的输入"><a href="#管理函数的输入" class="headerlink" title="管理函数的输入"></a>管理函数的输入</h2><blockquote>
<p>函数式编程者习惯于在重复做同一种事情的地方找到模式，并试着将这些行为转换为逻辑可重用的实用函数</p>
</blockquote>
<p>偏函数：在函数调用现场（function call-site），将实参应用（apply）于形参。偏函数是一个减少函数参数个数（arity）的过程</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn：被偏应用实参的函数</span></span><br><span class="line"><span class="comment">// presetArgs：提前传入的实参</span></span><br><span class="line"><span class="comment">// laterArgs；调用时传入的实参</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">partial</span>(<span class="params">fn, ...presetArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">partiallyApplied</span>(<span class="params">...laterArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...presetArgs, ...laterArgs)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>bind(..)</code>：预设 <code>this</code> 关键字的上下文，以及偏应用实参</p>
<p>将实参顺序颠倒</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reverseArgs</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">argsReversed</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...args.<span class="title function_">reverse</span>())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从右边开始偏应用实参（右偏应用实参）</p>
<p>这个函数不能保证让一个特定的形参接受特定的被偏应用的值，只能确保将被这些值（一个或几个）当作原函数最右边的实参（一个或几个）传入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partialRight</span>(<span class="params">fn, ...presetArgs</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">reverseArgs</span>(</span><br><span class="line">    <span class="title function_">partial</span>(<span class="title function_">reverseArgs</span>(fn), ...presetArgs.<span class="title function_">reverse</span>())</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>柯里化：将一个期望接收多个实参的函数拆解成连续的链式函数，每个链式函数接收单一实参并返回另一个接收下一个实参的函数</p>
<p>此函数默认基于如下条件：在拿到原函数期望的全部实参之前，我们能够通过检查将要被柯里化的函数的 <code>length</code> 属性来得知柯里化需要迭代多少次</p>
<p>如果需要用在一个 <code>length</code> 属性不明确的函数上（形参声明包含默认形参值&#x2F;形参解构&#x2F;可变参数函数等），需要明确传入 <code>arity</code> 参数来确保 <code>curry(..)</code> 函数的正常运行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">curry</span>(<span class="params">fn, arity = fn.length</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> <span class="title function_">nextCurried</span>(<span class="params">prevArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">nextArg</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> args = prevArgs.<span class="title function_">contact</span>([nextArg])</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">nextCurried</span>(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)([]) <span class="comment">// attention here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>柯里化和偏应用</p>
<ul>
<li>都是用来减少函数的参数数量的技术；柯里化是偏应用的一种特殊形式，其参数数量降低为 1</li>
<li>柯里化：每次函数调用传入一个实参，并生成另一个特定性更强的函数，之后我们可以在程序中获取并使用那个新函数</li>
<li>偏应用：预先指定所有将被偏应用的实参，产出一个等待接收剩下所有实参的函数</li>
<li>柯里化和偏应用都使用闭包来保存实参，直到收齐所有实参后再执行原函数</li>
<li>柯里化和偏应用可以将指定分离实参的时机和地方独立开来</li>
<li>当函数只有一个形参时，我们能够比较容易地组合它们</li>
</ul>
<p>松散柯里化：允许在每次柯里化调用中指定多个实参，允许传入超过 arity 的实参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">looseCurry</span>(<span class="params">fn, arity = fn.length</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> <span class="title function_">nextCurried</span>(<span class="params">prevArgs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">...nextArgs</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> args = prevArgs.<span class="title function_">concat</span>(nextArgs)</span><br><span class="line">      <span class="keyword">if</span> (args.<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">nextCurried</span>(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)([])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反柯里化</p>
<p>返回的结果是：如果传入原函数期望数量的实参，则函数的行为和原函数相同；而如果少传了实参，得到的是仍在等待传入更多实参的部分柯里化函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">uncurry</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">uncurried</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = fn</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; args.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      ret = <span class="title function_">ret</span>(args[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单参数函数：包装一个函数调用，确保被包装的函数只接受一个实参。即强制把一个函数处理成单参数函数</p>
<p>应用：例如 <code>map(..)</code> 函数调用时会传入三个实参，而只想接收一个</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">unary</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">onlyOneArg</span>(<span class="params">arg</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(arg)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// e.g.</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseFloat</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="built_in">parseInt</span>) <span class="comment">// [1, NaN, NaN]</span></span><br><span class="line">[<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>].<span class="title function_">map</span>(<span class="title function_">unary</span>(<span class="built_in">parseInt</span>)) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>identity 函数</p>
<ul>
<li>可以被用作判空的断言</li>
<li>可以将其作为替代一个转换函数的默认函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">identity</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>恒定参数</p>
<p>可以用于 Certain API（禁止直接给方法传值，必须传入函数，比如 JS Promise）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">constant</span>(<span class="params">v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">value</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展参数：调整一个函数，让它把能接收的单一数组扩展成各自独立的实参</p>
<p>也被称为 <code>apply(..)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spreadArgs</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">spreadFn</span>(<span class="params">argsArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...argsArr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚集参数</p>
<p>也被称为 <code>unapply(..)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">gatherArgs</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">gatheredFn</span>(<span class="params">...argsArr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(argsArr)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是柯里化还是偏应用，我们都用了上面的许多繁琐的技巧来修正这些形参的顺序，而这些繁琐的代码会把我们自己的代码混淆得一团糟…在第二章介绍了用解构实现命名实参，那么偏应用&#x2F;柯里化中也可以有对应的实用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">partialProps</span>(<span class="params">fn, presetArgsObj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">partiallyApplied</span>(<span class="params">laterArgsObj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(<span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, presetArgsObj, laterArgsObj))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">curryProps</span>(<span class="params">fn, arity = <span class="number">1</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">function</span> <span class="title function_">nextCurried</span>(<span class="params">prevArgsObj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">curried</span>(<span class="params">nextArgObj = &#123;&#125;</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> [key] = <span class="title class_">Object</span>.<span class="title function_">keys</span>(nextArgObj) <span class="comment">// nextArgObj has only one value</span></span><br><span class="line">      <span class="keyword">var</span> allArgsObj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, prevArgsObj, &#123; [key]: nextArgObj[key] &#125;)</span><br><span class="line">      <span class="keyword">if</span> (<span class="title class_">Object</span>.<span class="title function_">keys</span>(allArgsObj).<span class="property">length</span> &gt;= arity) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">fn</span>(allArgsObj)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">nextCurried</span>(allArgsObj)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在可以想传哪个位置的实参就传哪个了，但是我们需要掌握函数 <code>fn(..</code> 的函数签名，并且可以定义该函数的行为，使其解构第一个参数时，上面的技术才能起作用。那如果一个函数的形参是各自独立（没有经过形参解构），而且不改变它的函数签名，该怎么办呢</p>
<p>yep，just like <code>spreadArgs(...)</code></p>
<p>但是存在一个问题，<code>spreadArgs(...)</code> 中参数的顺序是明确的，然而对象属性的顺序不太明确且不可靠…一个最直观的想法是再传入一个类似 <code>[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;]</code> 这样的数组通知我们的实用函数明确的参数顺序，但是这好弱智！下面给出了一种 hack 技巧可以根据解析函数代码本身（由 <code>.toString()</code> 方法可以获得）得到每个单独的命名形参</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">spreadArgProps</span>(<span class="params"></span></span><br><span class="line"><span class="params">  fn,</span></span><br><span class="line"><span class="params">  propOrder = </span></span><br><span class="line"><span class="params">          fn.toString()</span></span><br><span class="line"><span class="params">          .replace(/^(?:(?:<span class="keyword">function</span>.*\(([^]*?)\))|(?:([^\(\)]+?)\s*=&gt;)|(?:\(([^]*?)\)\s*=&gt;))[^]+$/, <span class="string">&quot;$1$2$3&quot;</span>)</span></span><br><span class="line"><span class="params">          .split(/\s*,\s*/)</span></span><br><span class="line"><span class="params">          .map(v =&gt; v.replace( /[=\s].*$/, <span class="string">&quot;&quot;</span> ))</span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">spreadFn</span>(<span class="params">argsObj</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(...propOrder.<span class="title function_">map</span>(<span class="function"><span class="params">k</span> =&gt;</span> argsObj[k]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无形参风格（point-free）&#x2F;隐性编程（tacit programming）：通过移除不必要的形参-实参映射来减少视觉上的干扰，提高代码的可读性和可理解性</p>
<p>使用无形参风格的关键，是找到代码中，有哪些地方的函数直接将其形参作为内部函数调用的实参</p>
<p>取反函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">not</span>(<span class="params">predicate</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">negated</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="title function_">predicate</span>(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>when(..)</code> 实用函数：用于表示 <code>if</code> 条件句</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">when</span>(<span class="params">predicate, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">conditional</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicate</span>(...args)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合函数"><a href="#组合函数" class="headerlink" title="组合函数"></a>组合函数</h2><blockquote>
<p>函数有多种多样的形状和大小。我们能够定义某种组合方式，来让它们成为一种新的组合函数，程序中不同的部分都可以使用这个函数。这种将函数一起使用的过程叫做组合。</p>
</blockquote>
<p><code>compose2(..)</code> 实用函数：自动创建两个函数的组合（从右向左组合）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose2</span>(<span class="params">fn2, fn1</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">composed</span>(<span class="params">origValue</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn2</span>(<span class="title function_">fn1</span>(origValue))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用组合函数</p>
<p>这里的顺序依然是从右向左的，可以结合上一章所介绍的 <code>partialRight(..)</code> 实用函数把 <code>compose(..)</code> 的参数右偏，这样就可以先传入一些内层，之后再不断包外层函数（原本在参数列表左侧）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">composed</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list = fns.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">while</span> (list.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result = list.<span class="title function_">pop</span>()(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同的实现</p>
<p><strong>reduce</strong></p>
<p>上面的原始版本 <code>compose(..)</code> 使用一个循环并且饥渴的（立刻）执行计算，将一个调用的结果传递给下一个调用。这不就是 <code>reduce(..)</code>！</p>
<p><code>reduce(..)</code> 循环发生在最后的 <code>composed(..)</code> 运行时，并且每一个中间的 <code>result(..)</code> 将会在下一次调用时作为输入值传递给下一个迭代</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">composed</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fns.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">result, fn</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn</span>(result)</span><br><span class="line">    &#125;, result)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这种实现存在迭代问题是最内层的组合函数（也就是组合中的第一个函数）只能接受一个参数，如果组合中的每一个函数都是一元的，这个方案问题不大。但如果需要给第一个调用传递多参数…</p>
<blockquote>
<p>惰性运算：直接返回 <code>reduce(..)</code> 调用的结果，该结果自身就是个函数，不是一个计算过的值。该函数让我们能够传入任意数目的参数，在整个组合过程中，将这些参数传入到第一个函数调用中，然后一次铲除结果给到后面的调用</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> fns.<span class="title function_">reverse</span>().<span class="title function_">reduce</span>(<span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">fn1, fn2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">composed</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">fn2</span>(<span class="title function_">fn1</span>(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>递归</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> [fn1, fn2, ...rest] = fns.<span class="title function_">reverse</span>()</span><br><span class="line">  <span class="keyword">var</span> composedFn = <span class="keyword">function</span> <span class="title function_">composed</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn2</span>(<span class="title function_">fn1</span>(...args))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (rest.<span class="property">length</span> === <span class="number">0</span>) <span class="keyword">return</span> composedFn</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">compose</span>(...rest.<span class="title function_">reverse</span>(), composedFn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重排序组合：以函数执行的顺序来排列参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">pipe</span>(<span class="params">...fns</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">piped</span>(<span class="params">result</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> list = fns.<span class="title function_">slice</span>()</span><br><span class="line">    <span class="keyword">while</span> (list.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      result = list.<span class="title function_">shift</span>()(result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者，只是将 compose(..) 的参数反转就可以</span></span><br><span class="line"><span class="keyword">var</span> pipe = <span class="title function_">reverseArgs</span>(compose)</span><br></pre></td></tr></table></figure>

<p>抽象：对两个或多个任务公共部分的剥离。通用部分只定义一次，从而避免重复。为了展现每个任务的特殊部分，通用部分需要被参数化</p>
<blockquote>
<p>DRY: don’t repeat yourself. 力求能在程序的任何任务中有唯一的定义</p>
<p>我们不是为了隐藏细节而抽象，而是为了通过分离来突出关注点。</p>
<p>函数组合并不是通过 DRY 的原则来节省代码量，而是从<em>怎么做</em>中分离出<em>是什么</em></p>
</blockquote>
<h2 id="减少副作用"><a href="#减少副作用" class="headerlink" title="减少副作用"></a>减少副作用</h2><p><strong>副作用</strong></p>
<ul>
<li>有副作用的函数可读性更低，因为它需要更多的阅读来理解程序（不确定运行一个函数会不会影响其他地方，所以必须要去读函数内部逻辑）</li>
<li>所有决定函数输出的原因应该被设置的直接并明显，函数的使用者能直接看到原因和结果</li>
<li>并不是禁止引用所有自由变量，比如引用函数&#x2F; <code>Math.PI</code> 这种 <em>“常量”</em> 引用是可以的。因为它们在整个程序中都不改变，我们不需要担心将它们作为变化的状态追踪它们；同样，他们不会损害程序的可读性，而且它们也不会因为变量以不可预测的方式变化而成为错误的源头</li>
<li>随机数是不纯的</li>
<li>IO 是副作用</li>
<li>一系列有副作用的函数可能会在异步调用时顺序出问题（特别是回调！），从而对外部造成奇怪的影响</li>
</ul>
<p><strong>限制潜在问题</strong></p>
<ul>
<li>幂等<ul>
<li>数学中的幂等：在第一次调用后，如果你将该输出一次又一次地输入到操作中，其输出永远不会改变的操作</li>
<li>编程中的幂等：要求 <code>f(x)</code> 每次调用的结果和第一次调用的结果没有任何改变</li>
<li>在任何可能的情况下通过幂等的操作限制副作用要比不做限制的更新好得多</li>
</ul>
</li>
<li>纯函数：没有副作用的函数，是一种幂等函数<ul>
<li>给定相同的输入总是产生相同的输出</li>
<li>具有引用透明性：一个函数调用可以被它的输出值所代替，并且整个程序的行为不会改变</li>
<li>编程中的幂等</li>
<li>一个纯函数可以引用自由变量，只要这些自由变量不是侧因（e.g.闭包）</li>
<li>纯函数和不纯的函数的合成总是产生不纯的函数</li>
</ul>
</li>
</ul>
<blockquote>
<p>减少副作用的目的并不是它们在程序中<em>不能</em>被观察到，而是设计一个程序，让副作用尽可能的少，因为这使代码更容易理解。一个没有观察到的<em>发生</em>的副作用的程序，在这个目标上，并不像一个<em>不能</em>观察它们的程序那么有效</p>
<p>也就是说，对于那些不得不发生的副作用，我们应该尽可能确定程序的任何部分都<em>不能</em>观察到它们，而不仅仅是<em>不</em>观察它们</p>
</blockquote>
<p><strong>纯化</strong></p>
<p>纯度仅仅需要深入到皮肤，也就是说，函数的纯度是从外部判断的，只要一个函数的使用表现为纯的，它就是纯的</p>
<ul>
<li>使用词法自由变量导致的副作用：<ul>
<li>如果可以选择修改周围的代码，那么可以使用作用域来封装它们</li>
<li>如果无法在容器函数的内部封装修改代码（比如来自第三方库的函数），那么可以创建一个隔离副作用的接口函数：<ol>
<li>捕获受影响的当前状态</li>
<li>设置初始输入状态</li>
<li>运行不纯的函数</li>
<li>捕获副作用状态</li>
<li>恢复原来的状态</li>
<li>返回捕获的副作用状态</li>
</ol>
</li>
</ul>
</li>
<li>直接输入值（对象、数组等）的突变导致的副作用：再次创建一个接口函数来替代原始的不纯的函数去交互</li>
<li><code>this</code> 导致的：<ul>
<li><code>this</code> 是函数隐式的输入</li>
<li>创建一个接口函数，强制函数使用可预测的 <code>this</code> 上下文</li>
</ul>
</li>
</ul>
<h2 id="值的不可变性"><a href="#值的不可变性" class="headerlink" title="值的不可变性"></a>值的不可变性</h2><ul>
<li>原始值（number&#x2F;string&#x2F;boolean&#x2F;null&#x2F;undefined）：本身就是不可变的</li>
<li>JS 的 boxing 特性：当访问原始数据类型时（特别是 <code>number</code>&#x2F;<code>string</code>&#x2F;<code>boolean</code>），在这种情况下，JS 会自动的把它们包装成这个值对应的对象（<code>Number</code>&#x2F;<code>String</code>&#x2F;<code>Boolean</code>）</li>
<li>注意，字符串也是不可变的，<code>s[1] = &#39;E&#39;</code> 这种赋值会静默失败</li>
</ul>
<p>值的不可变性：当需要改变程序中的状态时，我们不能改变已存在的数据，而是必须创建和跟踪一个新的数据（比如数组，就以拷贝代替改变，不改变原数组而是拷贝出来再改变）</p>
<blockquote>
<p>常量：一个无法重新赋值的变量<br>常量与值的本质无关，无论常量承载何值，该变量都不能使用其他的值被进行重新赋值</p>
<p>我们应该担心的，并不是变量是否被重新赋值，而是<em>值是否会发生改变</em></p>
</blockquote>
<p><code>Object.freeze(..)</code> 只是将对象的顶层设为不可变，基本上相当于使用 <code>const</code> 声明对象的每个属性</p>
<ul>
<li><code>const arr = [1, 2, 3]</code> 得到的数组依然可变</li>
<li><code>Object.freeze([1, 2, 3])</code> 的确是不可变的数组</li>
</ul>
<p><strong>性能</strong></p>
<p>每次都重新复制一个数组，肯定会影响性能。如果只是比较少的状态变化，这样的性能损失可以接受（毕竟减少了 debug 时间！）；但如果需要频繁改变状态，那么每次都复制肯定是不行的。</p>
<p>解决办法是可以像 git 版本控制原理那样，用一个链表记录状态的变化过程。<a target="_blank" rel="noopener" href="http://facebook.github.io/immutable-js">Immutable.js</a> 提供了这样的不可变数据结构。</p>
<blockquote>
<p>无论世界上接收到的值是否可变，我们都应以它们是不可变的来对待，以此来避免副作用并使函数保持纯度</p>
<p>值不变在代码可读性上的意义，不在于不改变数据，而在于以不可变的眼光看待数据这样的约束。</p>
</blockquote>
<h2 id="闭包-vs-对象"><a href="#闭包-vs-对象" class="headerlink" title="闭包 vs 对象"></a>闭包 vs 对象</h2><blockquote>
<p>一个没有闭包的编程语言可以用对象来模拟闭包；一个没有对象的编程语言可以用闭包来模拟对象<br>我们可以认为闭包和对象是一样东西的两种表达方式</p>
</blockquote>
<ul>
<li>都可以表达状态集合</li>
<li>也都可以包含函数或者方法</li>
<li>啊哈，封装！</li>
</ul>
<blockquote>
<p>闭包将单个函数与一系列状态结合起来，而对象却在保有相同状态的基础上，允许任意数量的函数来操作这些状态<br>（当然，我们也可以在闭包返回的单个函数里写个 switch 之类的，来达到和对象的多个函数相同的实现效果）</p>
</blockquote>
<p>对象和闭包在可变这点上没有关系，因为我们关心的是<em>值</em>的可变性，值可变是值本身的特性，不在于在哪里或者如何被赋值的</p>
<p><strong>同构</strong></p>
<blockquote>
<p>两件事物 A 和 B 如果你能够映射（转化）A 到 B 并且能够通过反向映射回 A 那么它们就是同构</p>
<p>如果 JS 有同构的话是怎么样的？它可能是一集合的 JS 代码转化为了另一集合的 JS 代码，并且（重要的是）如果你愿意的话，你可以把转化后的代码转为之前的。</p>
</blockquote>
<p>闭包和对象是状态（及其相关功能）的同构表示</p>
<p><strong>区别</strong></p>
<ul>
<li>闭包的结构是不可变的（所以如果像复制数组这种操作，只能封装更多的闭包）；对象默认是完全可变的</li>
<li>闭包通过词法作用域提供“私有”状态；而对象将一切作为公共属性暴露（闭包这种信息隐藏反而不利于跟踪使用状态；同时，闭包具有控制内部变量只能被闭包内部代码操作的特性，这一点比之前讨论的 <code>const</code> 好用</li>
<li>像上一章提到的状态拷贝，在对象上很容易实现；而闭包上就很麻烦，需要额外定义很多拥有提取或拷贝隐藏值权限的函数…</li>
<li>对象在性能上通常比闭包好，因为 JS 对象通常在内存甚至计算角度是更加轻量的</li>
</ul>
<h2 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h2><p>非函数式编程的列表处理：</p>
<ul>
<li><code>forEach(..)</code>：有副作用！</li>
<li><code>some(..)</code>&#x2F;<code>every(..)</code>：虽然鼓励使用纯函数，但不可避免地将列表简化为 <code>true</code> 或 <code>false</code> 的值，本质上就像搜索和匹配</li>
</ul>
<h3 id="映射-map"><a href="#映射-map" class="headerlink" title="映射 map(...)"></a>映射 <code>map(...)</code></h3><p>映射：将一个值转换为另一个值（从一个地方映射到另一个新的地方）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">mapperFn, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newList = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; arr.<span class="property">length</span>; idx++) &#123;</span><br><span class="line">    newList.<span class="title function_">push</span>(<span class="title function_">mapperFn</span>(arr[idx], idx, arr))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>mapperFn(..)</code> 的参数和原生一致是三个，如果希望只传第一个进去，可以用之前介绍过的 <code>unary(..)</code> </p>
<p><code>map(..)</code> 使得可以方便的做列表的链式操作</p>
<p><code>map(..)</code> 的每个转换应该独立与其他的转换，没有从左往右的执行顺序</p>
<blockquote>
<p>函子是采用运算函数有效用操作的值<br>函子在每个单独的值上执行操作函数，函子实用函数创建的新值是所有单个操作函数执行结果的组合</p>
<p><code>map(..)</code> 函数采用关联值（数组）和映射函数（操作函数），并为数组中的每一个独立元素执行映射函数。最后，它返回由所有新映射值组成的新数组</p>
</blockquote>
<h3 id="过滤-filter"><a href="#过滤-filter" class="headerlink" title="过滤 filter(..)"></a>过滤 <code>filter(..)</code></h3><p><code>filter(..)</code> 中那个返回 <code>true/false</code> 来做决定（每一项在新数组中保留还是剔除）的函数有一个特别的称谓：谓词函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">filter</span>(<span class="params">predicateFn, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> newList = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> idx = <span class="number">0</span>; idx &lt; arr.<span class="property">length</span>; idx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicateFn</span>(arr[idx], idx, arr)) &#123;</span><br><span class="line">      newList.<span class="title function_">push</span>(arr[idx])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决语义问题（传入的谓词函数命名问题），我们定义</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterFn = filter</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterOut</span>(<span class="params">predicateFn, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">filterIn</span>(<span class="title function_">not</span>(predicateFn), arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// so...</span></span><br><span class="line"><span class="title function_">isOdd</span>(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">isEven</span>(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title function_">filterIn</span>(isOdd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [1, 3, 5]</span></span><br><span class="line"><span class="title function_">filterOut</span>(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="缩减-reduce"><a href="#缩减-reduce" class="headerlink" title="缩减 reduce(..)"></a>缩减 <code>reduce(..)</code></h3><p>&#x3D; 组合&#x2F;缩减&#x2F;折叠 &#x3D; 将两个值合并成一个值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reduce</span>(<span class="params">reducerFn, initialValue, arr</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> acc, startIdx</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> == <span class="number">3</span>) &#123;</span><br><span class="line">    acc = initialValue</span><br><span class="line">    startIdx = <span class="number">0</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    acc = arr[<span class="number">0</span>]</span><br><span class="line">    startIdx = <span class="number">1</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Must provide at least one value.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> idx = startIdx; idx &lt; arr.<span class="property">length</span>; idx++) &#123;</span><br><span class="line">    acc = <span class="title function_">reducerFn</span>(acc, arr[idx], idx, arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> acc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将 <code>reduce(..)</code> 认为是将函数从左到右组合（just like <code>pipe(..)</code>），可以这样使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">binary</span> = fn =&gt; <span class="function">(<span class="params">arg1, arg2</span>) =&gt;</span> <span class="title function_">fn</span>(arg1, arg2)</span><br><span class="line"><span class="keyword">var</span> pipeReducer = <span class="title function_">binary</span>(pipe)</span><br><span class="line"><span class="keyword">var</span> fn = [<span class="number">3</span>, <span class="number">17</span>, <span class="number">6</span>, <span class="number">4</span>]</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function"><span class="params">v</span> =&gt;</span> <span class="function"><span class="params">n</span> =&gt;</span> v * n)</span><br><span class="line">  .<span class="title function_">reduce</span>(pipeReducer)</span><br></pre></td></tr></table></figure>

<p>JS 还提供了 <code>reduceRight(..)</code></p>
<p><strong>map 也是 reduce</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">double</span> = v =&gt; v * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">map</span>(double) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">list, v</span>) =&gt;</span> (list.<span class="title function_">push</span>(<span class="title function_">double</span>(v)), list), []) <span class="comment">// [2, 4, 6, 8, 10]</span></span><br></pre></td></tr></table></figure>

<p><strong>filter 也是 reduce</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">isOdd</span> = v =&gt; v % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">filter</span>(isOdd) <span class="comment">// [1, 3, 5]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].<span class="title function_">reduce</span>(<span class="function">(<span class="params">list, v</span>) =&gt;</span> (</span><br><span class="line">  <span class="title function_">isOdd</span>(v) ? list.<span class="title function_">push</span>(v) : <span class="literal">undefined</span>,</span><br><span class="line">  list</span><br><span class="line">), []) <span class="comment">// [1, 3, 5]</span></span><br></pre></td></tr></table></figure>

<h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 indexOf 筛选时，是从左向右</span></span><br><span class="line"><span class="comment">// 找到的位置与 idx 相等说明该项是第一次出现</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">unique</span> = </span><br><span class="line">  arr =&gt;</span><br><span class="line">    arr.<span class="title function_">filter</span>(</span><br><span class="line">      <span class="function">(<span class="params">v, idx</span>) =&gt;</span></span><br><span class="line">        arr.<span class="title function_">indexOf</span>(v) === idx</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当列表项不能在新列表中找到时，将其插入到新的列表中</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">unique</span> = </span><br><span class="line">  arr =&gt;</span><br><span class="line">    arr.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">list, v</span>) =&gt;</span> </span><br><span class="line">        list.<span class="title function_">indexOf</span>(v) === -<span class="number">1</span> ? (list.<span class="title function_">push</span>(v), list) : list</span><br><span class="line">    , [])</span><br></pre></td></tr></table></figure>

<h3 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">flatten</span> = </span><br><span class="line">  arr =&gt; </span><br><span class="line">    arr.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">list, v</span>) =&gt;</span> </span><br><span class="line">        list.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? <span class="title function_">flatten</span>(v) : v)</span><br><span class="line">    , [])</span><br></pre></td></tr></table></figure>

<p><code>flatten(..)</code> 的常用用法之一是当你映射一组元素列表，并将每一项值从原来的值转换为数组（如果不想要返回的二维数组）</p>
<h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p>交替选择两个输入只能列表的值，并将得到的值组成子列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">zip</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> zipped = []</span><br><span class="line">  arr1 = arr1.<span class="title function_">slice</span>()</span><br><span class="line">  arr2 = arr2.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">while</span> (arr1.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; arr2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    zipped.<span class="title function_">push</span>([arr1.<span class="title function_">shift</span>(), arr2.<span class="title function_">shift</span>()])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> zipped</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个实现明显存在一些非函数式编程的思想。这里有一个命令式的 <code>while</code> 循环并且采用 <code>shift()</code> 和 <code>push(..)</code> 改变列表。虽然在纯函数中使用了非纯的行为（通常是为了性能），但只要其产生的副作用完全包含在这个函数内部，这种实现就是安全纯净的</p>
</blockquote>
<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mergeLists</span>(<span class="params">arr1, arr2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> merged = []</span><br><span class="line">  arr1 = arr1.<span class="title function_">slice</span>()</span><br><span class="line">  arr2 = arr2.<span class="title function_">slice</span>()</span><br><span class="line">  <span class="keyword">while</span> (arr1.<span class="property">length</span> &gt; <span class="number">0</span> || arr2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr1.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      merged.<span class="title function_">push</span>(arr1.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr2.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      merged.<span class="title function_">push</span>(arr2.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h3><p>JS 中通常使用链式调用，而函数式编程喜欢嵌套式的调用，但是用于 <code>compose(..)</code> 都不太合适…</p>
<p>链式组合方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">partialThis</span> = </span><br><span class="line">  (<span class="params">fn, ...presetArgs</span>) =&gt; </span><br><span class="line">    <span class="comment">// 故意用 function 为了获得 this 绑定</span></span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">partiallyApplied</span>(<span class="params">...laterArgs</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [...presetArgs, ...laterArgs])</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">composeChainedMethods</span> = </span><br><span class="line">  (<span class="params">...fns</span>) =&gt;</span><br><span class="line">    <span class="function"><span class="params">result</span> =&gt;</span></span><br><span class="line">      <span class="comment">// result 是前一步传入的 this</span></span><br><span class="line">      fns.<span class="title function_">reduceRight</span>(<span class="function">(<span class="params">result, fn</span>) =&gt;</span> fn.<span class="title function_">call</span>(result), result)</span><br><span class="line"></span><br><span class="line"><span class="title function_">composeChainedMethods</span>(</span><br><span class="line">  <span class="title function_">partialThis</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reduce</span>, sum, <span class="number">0</span>),</span><br><span class="line">  <span class="title function_">partialThis</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span>, double),</span><br><span class="line">  <span class="title function_">partialThis</span>(<span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">filter</span>, isOdd)</span><br><span class="line">)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>独立组合实用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">filter</span> = (<span class="params">arr, predicateFn</span>) =&gt; arr.<span class="title function_">filter</span>(predicateFn)</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">map</span> = (<span class="params">arr, mapperFn</span>) =&gt; arr.<span class="title function_">map</span>(mapperFn)</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">reduce</span> = (<span class="params">arr, reducerFn, initialValue</span>) =&gt; arr.<span class="title function_">reduce</span>(reduceFn, initialValue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr 是第一个，需要右偏一下</span></span><br><span class="line"><span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">partialRight</span>(reduce, sum, <span class="number">0</span>),</span><br><span class="line">  <span class="title function_">partialRight</span>(map, double),</span><br><span class="line">  <span class="title function_">partialRight</span>(filter, isOdd)</span><br><span class="line">)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不过一般函数式编程类库都是直接把 arr 放最后一个了</span></span><br><span class="line"><span class="comment">// 顺便还柯里化一下</span></span><br><span class="line"><span class="keyword">var</span> filter = <span class="title function_">curry</span>(</span><br><span class="line">  <span class="function">(<span class="params">predicateFn, arr</span>) =&gt;</span></span><br><span class="line">    arr.<span class="title function_">filter</span>(predicateFn)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> map = <span class="title function_">curry</span>(</span><br><span class="line">  <span class="function">(<span class="params">mapperFn, arr</span>) =&gt;</span></span><br><span class="line">    arr.<span class="title function_">map</span>(mapperFn)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> reduce = <span class="title function_">curry</span>(</span><br><span class="line">  <span class="function">(<span class="params">reducerFn, initialValue, arr</span>) =&gt;</span></span><br><span class="line">    arr.<span class="title function_">reduce</span>(reducerFn, initialValue)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完美！</span></span><br><span class="line"><span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">reduce</span>(sum)(<span class="number">0</span>),</span><br><span class="line">  <span class="title function_">map</span>(double),</span><br><span class="line">  <span class="title function_">filter</span>(idOdd)</span><br><span class="line">)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>发现上面的定义都很套路！都是派发相应的原生数组方法，那不就可以再写个函数做这件事！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">unboundMethod</span> = </span><br><span class="line">  (<span class="params">methodName, argCount = <span class="number">2</span></span>) =&gt;</span><br><span class="line">    <span class="title function_">curry</span>(</span><br><span class="line">      <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> obj = args.<span class="title function_">pop</span>()</span><br><span class="line">        <span class="keyword">return</span> obj[methodName](...args)</span><br><span class="line">      &#125;,</span><br><span class="line">      argCount <span class="comment">// 第二个参数是 arity</span></span><br><span class="line">    )</span><br><span class="line"><span class="keyword">var</span> filter = <span class="title function_">unboundMethod</span>(<span class="string">&#x27;filter&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> map = <span class="title function_">unboundMethod</span>(<span class="string">&#x27;map&#x27;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> reduce = <span class="title function_">unboundMethod</span>(<span class="string">&#x27;reduce&#x27;</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直到这时才确定 curry 里面的第一个函数的 obj = args.pop()</span></span><br><span class="line"><span class="comment">// 事实上是 this！（也就是 Array Object）</span></span><br><span class="line"><span class="comment">// methodName 被闭包保存起来了</span></span><br><span class="line"><span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">reduce</span>(sum)(<span class="number">0</span>),</span><br><span class="line">  <span class="title function_">map</span>(double),</span><br><span class="line">  <span class="title function_">filter</span>(idOdd)</span><br><span class="line">)</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>

<p>当然咧，也有办法把我们的独立函数（上面定义的 去重 扁平 zip 等等）变成可以链式调用的数组方法（当然不是直接改 <code>Array.prototype</code> ！）。一个思路是把独立函数适配成一个缩减函数，然后传给 <code>reduce(..)</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原独立函数的定义</span></span><br><span class="line"><span class="keyword">var</span> <span class="title function_">flatten</span> = </span><br><span class="line">  arr =&gt; </span><br><span class="line">    arr.<span class="title function_">reduce</span>(</span><br><span class="line">      <span class="function">(<span class="params">list, v</span>) =&gt;</span> </span><br><span class="line">        list.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? <span class="title function_">flatten</span>(v) : v)</span><br><span class="line">    , [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">flattenReducer</span>(<span class="params">list, v</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">concat</span>(</span><br><span class="line">    <span class="title class_">Array</span>.<span class="title function_">isArray</span>(v) ? v.<span class="title function_">reduce</span>(flattenReducer, []) : v</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>, <span class="number">5</span>, [<span class="number">6</span>, [<span class="number">7</span>, <span class="number">8</span>]]]</span><br><span class="line">.<span class="title function_">reduce</span>(flattenReducer, [])</span><br></pre></td></tr></table></figure>

<p>条件确保实用函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title function_">guard</span> = </span><br><span class="line">  fn =&gt;</span><br><span class="line">    <span class="function"><span class="params">arg</span> =&gt;</span></span><br><span class="line">      arg != <span class="literal">null</span> ? <span class="title function_">fn</span>(arg) : arg</span><br></pre></td></tr></table></figure>

<p><strong>链式组合风格</strong>：声明式的，很容易看出详尽的执行步骤和顺序；但每一个列表操作都需要循环整个列表，意味着不必要的性能损失</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">someList</span><br><span class="line">.<span class="title function_">filter</span>(..)</span><br><span class="line">.<span class="title function_">filter</span>(..)</span><br><span class="line">.<span class="title function_">map</span>(..)</span><br><span class="line">.<span class="title function_">map</span>(..)</span><br><span class="line">.<span class="title function_">map</span>(..)</span><br><span class="line">.<span class="title function_">reduce</span>(..)</span><br></pre></td></tr></table></figure>

<p><strong>交替独立风格</strong>：操作自下而上列出，同样会多次循环列表</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">map</span>(</span><br><span class="line">  fn3,</span><br><span class="line">  <span class="title function_">map</span>(</span><br><span class="line">    fn2,</span><br><span class="line">    <span class="title function_">map</span>(fn1, someList)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>融合</strong>：合并相邻的操作，从而减少列表的迭代次数</p>
<p>一个简单的例子，对于连续的 <code>map(..)</code> 链式，可以很容易想到，把几个内层函数 <code>compose(..)</code> or <code>pipe(..)</code> 起来，从而只需遍历一次列表</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><blockquote>
<p>递归深谙函数式编程之精髓，最被广泛引证的原因是，在调用栈中，递归把（大部分）显式状态跟踪换为了隐式状态。通常，但问题需要条件分支和回溯计算时，递归非常有用，此外在纯迭代环境中管理这种状态，是相当棘手的；最起码，这些代码是不可或缺且晦涩难懂。但是在堆栈上调用每一级的分支作为其自己的作用域，很明显，这通常会影响到代码的可读性。</p>
<p>正如 Σ 是为运算而声明（符号是数学的声明式语言！），递归是为算法而声明</p>
</blockquote>
<h3 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h3><p>如果一个回调从函数 <code>baz()</code> 转到函数 <code>bar()</code> 的时候，而回调是在函数 <code>baz()</code> 的最底部执行——也就是尾调用——那么 <code>baz()</code> 的堆栈帧就不再需要了。也就意味着，内存可以被回收，或只需简单的执行 <code>bar()</code> 函数</p>
<p>正确的尾调用（PTC）：由 ES6 明确规定的尾调用特定形式，只要正确的使用了尾调用就不会发生栈溢出。PTC 长下面这样：函数调用在最后一步，并且必须有返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PTC</span></span><br><span class="line"><span class="keyword">return</span> <span class="title function_">foo</span>(..);</span><br><span class="line"></span><br><span class="line"><span class="comment">// this is also right</span></span><br><span class="line"><span class="keyword">return</span> x ? <span class="title function_">foo</span>(..) : <span class="title function_">bar</span>(..);</span><br></pre></td></tr></table></figure>

<p>如果你的递归比较复杂，不是尾递归（比如二分法），就需要想办法重构递归：</p>
<p><strong>更换堆栈</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个不符合 PTC 规范的例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, ...nums</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> num1</span><br><span class="line">  <span class="keyword">return</span> num1 + <span class="title function_">sum</span>(...nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>重构策略的关键点在于，我们可以通过把<em>置后</em>处理累加改为<em>提前</em>处理，来消除对堆栈的依赖，然后将该部分结果作为参数传递到递归调用。换句话说，我们不用在当前运用函数的堆栈帧中保留 <code>num1+sum(..num1)</code> 的总和，而是把它传递到下一个递归的堆栈帧中，这样就能释放当前递归的堆栈帧。</p>
</blockquote>
<p>也就是说，我们可以把 sum 计算的结果作为参数传进 sum：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">result, num1, ...nums</span>) &#123;</span><br><span class="line">  result = result + num1</span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> result</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sum</span>(result, ...nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是调用者需要在调用时额外传一个 <code>result = 0</code> 进去！通常的处理是再用一个函数包裹它，对外暴露一个接口函数（各种方法实现，平级函数&#x2F;内部函数&#x2F;IIFE 包裹等等）。但是这样可读性已经明显降低…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, ...nums</span>) &#123;</span><br><span class="line">  num1 = num1 + num2 <span class="comment">// 啊哈，直接把 num1 当成初始的 result</span></span><br><span class="line">  <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> num1</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sum</span>(num1, ...nums)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">maxEven</span>(<span class="params">num1, ...restNums</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> maxRest = restNums.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="title function_">maxEven</span>(...restNums) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> (num1 % <span class="number">2</span> != <span class="number">0</span> || num1 &lt; maxRest) ? maxRest : num1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">maxEven</span>(<span class="params">num1, num2, ...nums</span>) &#123;</span><br><span class="line">  num1 = (num1 % <span class="number">2</span> == <span class="number">0</span> &amp;&amp; !(<span class="title function_">maxEven</span>(num2) &gt; num1)) ? num1 : (num2 % <span class="number">2</span> == <span class="number">0</span> ? num2 : <span class="literal">undefined</span>)</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="property">length</span> == <span class="number">0</span> ? num1 : <span class="title function_">maxEven</span>(num1, ...nums)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调 maxEven(num2) 不是为了 PTC 优化，而只是想避免重复写 % 逻辑（这里只递归一级就返回了）</span></span><br></pre></td></tr></table></figure>

<p><strong>后继传递格式</strong></p>
<blockquote>
<p>后继传递格式（CPS）：组织代码，使得每个函数在其结束时接受另一个执行函数</p>
</blockquote>
<p>比如进行相互递归的这个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fib_</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="title function_">fib</span>(n - <span class="number">1</span>) + <span class="title function_">fib_</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CPS</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fib</span>(<span class="params">n, cont = identity</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="title function_">cont</span>(n)</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">fib</span>(</span><br><span class="line">    n - <span class="number">2</span>,</span><br><span class="line">    <span class="function"><span class="params">n2</span> =&gt;</span> <span class="title function_">fib</span>( <span class="comment">// 这个函数接受 fib(n-2) 的结果作为 n2</span></span><br><span class="line">      n - <span class="number">1</span>,</span><br><span class="line">      <span class="function"><span class="params">n1</span> =&gt;</span> <span class="title function_">cont</span>(n2 + n1) <span class="comment">// 这个函数接受 fib(n-1) 的结果作为 n1，得到 n1 n2 后相加传入下个后续函数</span></span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>弹簧床</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trampoline</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">trampolined</span>(<span class="params">...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="title function_">fn</span>(...args)</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">typeof</span> result == <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      result = <span class="title function_">result</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="title function_">trampoline</span>(</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1, num2, ...nums</span>) &#123;</span><br><span class="line">    num1 = num1 + num2</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="property">length</span> == <span class="number">0</span>) <span class="keyword">return</span> num1</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="title function_">sum</span>(num1, ...nums)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="异步的函数式"><a href="#异步的函数式" class="headerlink" title="异步的函数式"></a>异步的函数式</h2><blockquote>
<p>异步编程最为重要的一点是通过抽象时间来简化状态变化的管理。</p>
</blockquote>
<p>promise 以时间无关的方式来作为一个单一的值。此外，获取 promise 的返回值是异步的，但却是通过同步的方法来赋值。或者说，promise 给 <code>=</code> 操作符扩展随时间动态赋值的功能，通过可靠的（时间无关）方式。</p>
<p>惰性数据结构 懒操作</p>
<p>observables(RxJS Most)</p>
<ul>
<li>数组的 <code>map(..)</code> 方法会用当前数组中的每一个值运行一次映射函数，然后放到返回的数组里（积极的数据结构）</li>
<li>observable 数组里则是为每一个值运行一次映射函数，无论这个值何时加入，然后把它返回到 observable 里（持续惰性的）</li>
</ul>
<h2 id="Transducing"><a href="#Transducing" class="headerlink" title="Transducing"></a>Transducing</h2><p>transduer 就是可组合的 reducer，也就是可以 compose 一系列 reduce 操作，避免反复遍历列表（而 map filter 等可以转成 reduce）</p>
<p>推导过程如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line"><span class="comment">// 这样反复遍历性能很差，而且可读性也很差</span></span><br><span class="line">words</span><br><span class="line">.<span class="title function_">map</span>(strUppercase)</span><br><span class="line">.<span class="title function_">filter</span>(isLongEnough)</span><br><span class="line">.<span class="title function_">filter</span>(isShortEnough)</span><br><span class="line">.<span class="title function_">reduce</span>(strConcat, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 map/filter 表示为 reduce</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapReducer</span>(<span class="params">mapperFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> list.<span class="title function_">concat</span>([<span class="title function_">mapperFn</span>(val)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterReducer</span>(<span class="params">predicateFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicateFn</span>(val)) <span class="keyword">return</span> list.<span class="title function_">concat</span>([val])</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有个共享功能！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listCombination</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> list.<span class="title function_">concat</span>([val])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 listCombination 这个小工具参数化进我们的 reducers</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapReducer</span>(<span class="params">mapperFn, combinationFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">combinationFn</span>(list, <span class="title function_">mapperFn</span>(val))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">filterReducer</span>(<span class="params">predicateFn, combinationFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicateFn</span>(val)) <span class="keyword">return</span> <span class="title function_">combinationFn</span>(list, val)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curry 一下</span></span><br><span class="line"><span class="keyword">var</span> curriedMapReducer = <span class="title function_">curry</span>(<span class="keyword">function</span> <span class="title function_">mapReducer</span>(<span class="params">mapperFn, combinationFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">combinationFn</span>(list, <span class="title function_">mapperFn</span>(val))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> curriedFilterReducer = <span class="title function_">curry</span>(<span class="keyword">function</span> <span class="title function_">filterReducer</span>(<span class="params">predicateFn, combinationFn</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">predicateFn</span>(val)) <span class="keyword">return</span> <span class="title function_">combinationFn</span>(list, val)</span><br><span class="line">    <span class="keyword">return</span> list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来是就是奇迹发生</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让我们看看柯里化没传全参数的样子</span></span><br><span class="line"><span class="comment">// 嗯，它们每个都期望得到一个 listCombination 并产生一个独立的 reducer</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="title function_">curriedMapReducer</span>(strUppercase)</span><br><span class="line"><span class="keyword">var</span> y = <span class="title function_">curriedFilterReducer</span>(isLongEnough)</span><br><span class="line"><span class="keyword">var</span> z = <span class="title function_">curriedFilterReducer</span>(isShortEnough)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是，如果调用 y(z)，会发生什么？</span></span><br><span class="line"><span class="comment">// 我们得到的 reducer 函数内部看起来会像这样</span></span><br><span class="line"><span class="comment">// 当然，这样是错的，因为我们的 z 只想接收一个参数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isLongEnough</span>(val)) <span class="keyword">return</span> <span class="title function_">z</span>(list, val) <span class="comment">// here</span></span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 y(z(listCombination)) 这样呢</span></span><br><span class="line"><span class="keyword">var</span> shortEnoughReducer = <span class="title function_">z</span>(listCombination) <span class="comment">// 正常滴</span></span><br><span class="line"><span class="keyword">var</span> longAndShortEnoughReducer = <span class="title function_">y</span>(shortEnoughReducer) <span class="comment">// 为什么叫这个名字？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看它们的内部</span></span><br><span class="line"><span class="comment">// shortEnoughReducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isShortEnough</span>(val)) <span class="keyword">return</span> <span class="title function_">listCombination</span>(list, val)</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// longAndShortEnoughReducer</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isLongEnough</span>(val)) <span class="keyword">return</span> <span class="title function_">shortEnoughReducer</span>(list, val) <span class="comment">// here!!!</span></span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事实是，上面这样写就能运行！而且是正确的！</span></span><br><span class="line"><span class="comment">// 因为 reducer(..) 的形状和 listCombination(..) 是一样的</span></span><br><span class="line"><span class="comment">// 可以理解为，都是“接收一个列表和一个值，返回一个新列表”</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那就可以这样把所有的 reducers compose 起来了！</span></span><br><span class="line"><span class="comment">// 需要注意的一点是，最终的执行顺序就是 strUppercase isLongEnough isShortEnough</span></span><br><span class="line"><span class="comment">// 因为每个 reducer 里面反转了顺序</span></span><br><span class="line"><span class="keyword">var</span> composition = <span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">curriedMapReducer</span>(strUppercase),</span><br><span class="line">  <span class="title function_">curriedFilterReducer</span>(isLongEnough),</span><br><span class="line">  <span class="title function_">curriedFilterReducer</span>(isShortEnough)</span><br><span class="line">)</span><br><span class="line">words.<span class="title function_">reduce</span>(<span class="title function_">composition</span>(listCombination), [])</span><br></pre></td></tr></table></figure>

<p>最后的一些讨论：</p>
<ul>
<li>我们的 <code>listCombination(..)</code> 内部用了纯的 <code>concat(..)</code>，但是这样性能肯定不好。是不是可以直接换成性能更好但不纯的 <code>push(..)</code> 呢？答案是可以。因为我们知道 <code>listCombination(..)</code> 只会在 transducing 内部使用，没有违反对外是纯函数这一准则，内部可以为了性能而变得不纯</li>
<li>如果两个“形状”不一样的组合函数呢？</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们可以“组合”这两个 reduce 吗？</span></span><br><span class="line">words</span><br><span class="line">.<span class="title function_">reduce</span>(<span class="title function_">transducer</span>(listCombination), [])</span><br><span class="line">.<span class="title function_">reduce</span>(strConcat, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接把 strConcat 放进我们的 compose 中是不行的，因为它的“形状”不适用于那个 compose</span></span><br><span class="line"><span class="comment">// 但让我们看看这两个“形状”</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">strConcat</span>(<span class="params">str1, str2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str1 + str2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">listCombination</span>(<span class="params">list, val</span>) &#123;</span><br><span class="line">  list.<span class="title function_">push</span>(val)</span><br><span class="line">  <span class="keyword">return</span> list</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嗯？在概念上这两个功能是一样的：将两个值组合成一个</span></span><br><span class="line"><span class="comment">// strConcat 也是一个组合函数！</span></span><br><span class="line"><span class="comment">// 我们最终的目标是获得字符串！那就可以直接用 strConcat 代替 listCombination</span></span><br><span class="line">words.<span class="title function_">reduce</span>(<span class="title function_">transducer</span>(strConcat), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// BOOM! This is transducing!</span></span><br></pre></td></tr></table></figure>

<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><blockquote>
<p>函子（functor）：包括一个值和一个用来对构成函子对数据执行操作的类 map 实用函数。</p>
<p>Monad：一个包含一些额外行为的函子。它更像是一种根据不同值的需要而用不同方式实现的接口，每一种实现都是一种不同类型的 Monad。Monad 是一个用更具有声明式的方式围绕一个值来组织行为的方法。</p>
</blockquote>
<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>如果一个值是非空的，它是 <code>Just(..)</code> 的实例；如果该值是空的，它则是 <code>Nothing()</code> 的实例</p>
<p>Maybe Monad 的价值在于不论我们有 <code>Just(..)</code> 实例还是 <code>Nothing(..)</code> 实例，我们使用的方法都是一样的。Maybe 这个抽象概念的作用是隐式地封装了操作和无操作的二元性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Maybe</span> = &#123;</span><br><span class="line">  <span class="title class_">Just</span>,</span><br><span class="line">  <span class="title class_">Nothing</span>,</span><br><span class="line">  <span class="attr">of</span>: <span class="title class_">Just</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Just</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="comment">// 无论 Just 实例拿到的是怎样的一个 val，Just 都不会改变它，所有的方法都会创建一个新的 Monad 实例而不是改变它</span></span><br><span class="line">  <span class="keyword">return</span> &#123; map, chain, ap, inspect &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">map</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Just</span>(<span class="title function_">fn</span>(val))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">chain</span>(<span class="params">fn</span>) &#123; <span class="comment">// 也叫 bind/flatMap</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">fn</span>(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">ap</span>(<span class="params">anotherMonad</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> anotherMonad.<span class="title function_">map</span>(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inspect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Just(<span class="subst">$&#123;val&#125;</span>)`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Nothing</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">map</span>: <span class="title class_">Nothing</span>,</span><br><span class="line">    <span class="attr">chain</span>: <span class="title class_">Nothing</span>,</span><br><span class="line">    <span class="attr">ap</span>: <span class="title class_">Nothing</span>,</span><br><span class="line">    inspect</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">inspect</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Nothing&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Monad 的核心思想是，它必须对所有值都是有效的，不能对值做任何检查——甚至是空值检查</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在外部进行空值检查的例子</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isEmpty</span>(<span class="params">val</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> val === <span class="literal">null</span> || val === <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> safeProp = <span class="title function_">curry</span>(<span class="keyword">function</span> <span class="title function_">safeProp</span>(<span class="params">prop, obj</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isEmpty</span>(obj[prop])) <span class="keyword">return</span> <span class="title class_">Maybe</span>.<span class="title class_">Nothing</span>()</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Maybe</span>.<span class="title function_">of</span>(obj[prop])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Maybe</span>.<span class="title function_">of</span>(someObj)</span><br><span class="line">.<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;something&#x27;</span>))</span><br><span class="line">.<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;else&#x27;</span>))</span><br><span class="line">.<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;entirely&#x27;</span>))</span><br><span class="line">.<span class="title function_">map</span>(<span class="variable language_">console</span>.<span class="property">log</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Humble"><a href="#Humble" class="headerlink" title="Humble"></a>Humble</h3><p>是一个产生 Maybe Monad 实例的工厂函数，可以加入各种条件判断…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/06/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8C%97/" class="post-title-link" itemprop="url">读书笔记-函数式编程指北</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-04 13:26:00" itemprop="dateCreated datePublished" datetime="2020-06-04T13:26:00+08:00">2020-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:35:23" itemprop="dateModified" datetime="2023-08-23T01:35:23+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><blockquote>
<p>《函数式编程指北》读书笔记</p>
<p><a target="_blank" rel="noopener" href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/">中文版</a></p>
</blockquote>
<h2 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h2><p>和其他对象一样，可以像对待任何其他数据类型一样对待它们——把它们存在数组里，当作参数传递，赋值给变量…等等</p>
<p>非常小心 <code>this</code> 值，特别是以一等公民的方式调用 this…</p>
<h2 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h2><p>相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用</p>
<p>纯函数不依赖外部环境，从而降低了认知负荷；函数能够做到自给自足。更可以用 <code>Object.freeze</code> 把对象变成不可变的，从而保留纯粹性，因为状态不会有变化</p>
<p>副作用是计算结果的过程中，系统状态的一种变化，或者与外部世界进行的可观察的交互</p>
<p>函数式编程的哲学就是假定副作用是造成不正当行为的主要原因</p>
<p>纯函数的优点：</p>
<ul>
<li>可缓存性（Cacheable）：总能够根据输入来做缓存，一种典型方式是 memoize 技术</li>
<li>可移植性&#x2F;自文档化（Portable&#x2F;Self-Documenting）：依赖明确（所有的依赖都需用函数的参数传递），纯函数对其依赖必须要诚实，并且参数化能够使应用更加灵活，与环境无关</li>
<li>可测试性（Testable）：只需要简单地给函数一个输入，然后断言输出就好了</li>
<li>合理性（Reasonable）：引用透明性（referential transparency，即如果一段代码可以替换成它执行所得的结果，而且是在不改变整个程序行为的前提下替换的）</li>
<li>并行代码：因为纯函数根本不需要访问共享的内存，也不会因副作用而进入竞争态，所以我们可以并行运行任意纯函数</li>
</ul>
<p>可以通过延迟执行的方式把不纯的函数转换为纯函数</p>
<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p>
<p>lodash 的 curry 方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_.<span class="title function_">curry</span>(func, [arity=func.<span class="property">length</span>])</span><br><span class="line"><span class="comment">// 创建一个函数，该函数接受 func 的参数</span></span><br><span class="line"><span class="comment">// 如果全部参数已经提供，则直接返回 func 执行的结果</span></span><br><span class="line"><span class="comment">// 否则返回一个函数，接受余下的参数</span></span><br></pre></td></tr></table></figure>

<p>对于传进去的 <code>func</code> 的参数，需要把要操作的数据放到最后一个参数</p>
<p>表明了一种“预加载”函数的能力，通过传递一到两个参数调用函数，就能得到一个记住了这些参数的新函数</p>
<p>只传给函数一部分参数通常也叫作局部调用，能够大量减少样板文件代码</p>
<p>curry 函数是纯函数</p>
<h2 id="代码组合"><a href="#代码组合" class="headerlink" title="代码组合"></a>代码组合</h2><p>compose：将两个函数结合起来，得到一个新函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compose = <span class="keyword">function</span>(<span class="params">f, g</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">f</span>(<span class="title function_">g</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>g</code> 先于 <code>f</code> 执行，从右向左的数据流</p>
<h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><p>如何为 <code>compose</code> 的调用分组不重要，结果是一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> associative = <span class="title function_">compose</span>(f, <span class="title function_">compose</span>(g, h)) == <span class="title function_">compose</span>(<span class="title function_">compose</span>(f, g), h); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>因此，可以给 <code>compose</code> 传递很多参数而不必自己手动分组，它自己会决定如何分组（这个时候 <code>compose</code> 就不是上面写的那个只接受两个参数的了，而要写个多个的）</p>
<p>因为有了结合律，所以任何一个函数分组都可以被拆开来，然后再以它们自己的组合方式打包在一起</p>
<p>如何组合的最佳实践：让组合可重用</p>
<h3 id="pointfree"><a href="#pointfree" class="headerlink" title="pointfree"></a>pointfree</h3><p>函数无须提及将要操作的数据是什么样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非 pointfree，因为提到了数据：word</span></span><br><span class="line"><span class="keyword">var</span> snakeCase = <span class="keyword">function</span> (<span class="params">word</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> word.<span class="title function_">toLowerCase</span>().<span class="title function_">replace</span>(<span class="regexp">/\s+/ig</span>, <span class="string">&#x27;_&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pointfree</span></span><br><span class="line"><span class="keyword">var</span> snakeCase = <span class="title function_">compose</span>(<span class="title function_">replace</span>(<span class="regexp">/\s+/ig</span>, <span class="string">&#x27;_&#x27;</span>), toLowerCase);</span><br></pre></td></tr></table></figure>

<p>一等公民的函数+柯里化+组合协作起来，通过<strong>管道</strong>把数据在接受单个参数的函数间传递</p>
<p>pointfree 模式能够帮助我们减少不必要的命名，让代码保持简洁和通用 </p>
<p>在组合时注意如果想组合类似 <code>map</code> 这种接受两个参数的函数，需要先对 <code>map</code> 局部调用使得其返回接受一个参数的函数</p>
<p>在 debug 过程中可以用 <code>trace</code> 函数来追踪代码执行情况，在想要观察的特定点（管道的某一环）观察数据</p>
<h3 id="范畴学"><a href="#范畴学" class="headerlink" title="范畴学"></a>范畴学</h3><p>把很多数学分支（集合论、类型论、群论、逻辑学等…）中相同的概念加以形式化</p>
<blockquote>
<p>…范畴：有以下这些组件（component）的搜集（collection）就构成了一个范畴</p>
<ul>
<li>对象的搜集</li>
<li>态射的搜集</li>
<li>态射的组合</li>
<li>indentity 这个独特的态射</li>
</ul>
</blockquote>
<p>对应到编程上：</p>
<ul>
<li><p>对象的搜集：数据类型，例如 String Boolean Number Object 等。通常我们把数据类型视作所有可能的值得一个集合，这样可以用集合论处理类型</p>
</li>
<li><p>态射的搜集：态射是标准的、普通的纯函数</p>
</li>
<li><p>态射的组合：本章介绍的组合 <code>compose</code>。在范畴学中任何组合都适用结合律</p>
</li>
<li><p>indentity 这个独特的态射</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id = <span class="keyword">function</span>(<span class="params">x</span>) &#123; <span class="keyword">return</span> x; &#125;;</span><br></pre></td></tr></table></figure>

<p>有了 <code>id</code> 函数，就可以有单位律（和实数的单位元一样）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">compose</span>(id, f) = <span class="title function_">compose</span>(f, id) == f;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="示例应用"><a href="#示例应用" class="headerlink" title="示例应用"></a>示例应用</h2><p>声明式代码：指明“做什么“，而不是”怎么做“</p>
<table>
<thead>
<tr>
<th>命令式</th>
<th>声明式</th>
</tr>
</thead>
<tbody><tr>
<td>for 循环，硬编码处理迭代累加blabla…</td>
<td>map</td>
</tr>
<tr>
<td>硬编码顺序调用函数</td>
<td>compose 组合函数，不指定执行顺序（天然地适合并行运算），为潜在的代码更新提供支持</td>
</tr>
</tbody></table>
<p><strong>map 的组合律</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> law = <span class="title function_">compose</span>(<span class="title function_">map</span>(f), <span class="title function_">map</span>(g)) == <span class="title function_">map</span>(<span class="title function_">compose</span>(f, g));</span><br></pre></td></tr></table></figure>

<p>可以用来重构代码（就像数学推导公式一样）</p>
<h2 id="类型签名"><a href="#类型签名" class="headerlink" title="类型签名"></a>类型签名</h2><p>Hindley-Milner 系统</p>
<p>函数写成 <code>a -&gt; b</code> 的样子，表示接受值和返回值</p>
<p>连续指向</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map :: (a -&gt; b) -&gt; [a] -&gt; [b]</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, xs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>最简单的理解：map 接受两个参数，第一个是 <code>f</code>，类型为 <code>a -&gt; b</code>；第二个是 <code>xs</code>，类型为 <code>[a]</code>；返回一个数组 <code>[b]</code></p>
<p>深入理解：从右向左加括号 <code>(a -&gt; b) -&gt; ([a] -&gt; [b])</code>，外层是输入一个 <code>a -&gt; b</code> 返回 <code>[a] -&gt; [b]</code>，输入一个函数返回一个函数；内层是 <code>[a] -&gt; [b]</code>，输入数组返回数组</p>
<p>仅仅根据类型签名，就可以理解函数做了什么事情，比如 map 其实就是在每个 <code>a</code> 上调用一次 <code>f</code>(<code>a -&gt; b</code>)，从而得到一个 <code>[b]</code></p>
<p>另一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reduce :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b</span></span><br><span class="line"><span class="keyword">var</span> reduce = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, x, xs</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> xs.<span class="title function_">reduce</span>(f, x);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>理解：</p>
<ul>
<li>第一个参数<code>f</code>：<code>(b -&gt; a -&gt; b)</code>，接受一个 <code>b</code> 一个 <code>a</code>，返回 <code>b</code></li>
<li>那么这里的 a b 来源于哪里呢，其实就在第二三个参数 <code>b</code> 和 <code>[a]</code>，这里的 b a 会传给 f 作为参数</li>
<li>reduce 的最终返回结果是一个 <code>b</code>，其实就是 <code>f :: b -&gt; a -&gt; b</code> 的这个输出 <code>b</code></li>
<li>对照 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce">reduce 的真实定义</a> 来理解：<ul>
<li><code>f</code> 即要对数组中每个值执行的函数，它的参数实际上是：<code>b</code> 为 <code>accumulator</code> 即累计回调的值，<code>a</code> 为 <code>currentValue</code> 即正在处理的当前数组元素</li>
<li><code>x</code> 是第一次调用 <code>f</code> 时的初始值</li>
<li><code>xs</code> 是数组，不用讲了…</li>
</ul>
</li>
</ul>
<h3 id="Parametricity"><a href="#Parametricity" class="headerlink" title="Parametricity"></a>Parametricity</h3><p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Parametricity">wiki</a> （暂时还没理解这个概念啥意思）</p>
<p>但反正这个特性表明，<strong>函数将会以一种统一的行为作用于所有的类型</strong></p>
<p>也就是说，在看着类型签名进行函数功能的推断时，要保证函数对每一个可能的类型操作必须保持统一，这样就能缩小可能的功能的范围</p>
<p>例如，<code>// head :: [a] -&gt; a</code>，a 可能是任意类型，所以函数在对 <code>a</code> 一无所知的情况下，可能对 <code>[a]</code> 进行的操作，只可能是返回数组中的某个元素</p>
<h3 id="自由定理"><a href="#自由定理" class="headerlink" title="自由定理"></a>自由定理</h3><p>根据（多态）类型签名，可以无需知道函数具体实现的情况就对函数表达式进行推导得到一些普适的重写规则，从而可以重构代码，提高代码效率</p>
<h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>也可以把类型约束为一个特定的接口（interface）</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="Indentity"><a href="#Indentity" class="headerlink" title="Indentity"></a>Indentity</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Container</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="comment">// 装载任意类型的值</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__value</span> = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="title class_">Container</span>.<span class="property">of</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Container</span>(x); </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 一个让别的函数（f）能操作容器中值的方法</span></span><br><span class="line"><span class="comment">// 这样就可以不离开 Container 而操作容器里面的值</span></span><br><span class="line"><span class="comment">// 可以 Container.of(2).map(blabla).map(blabla) 连续调用</span></span><br><span class="line"><span class="comment">// 啊哈，那 map 就是个组合（compostion）了</span></span><br><span class="line"><span class="title class_">Container</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Contain</span>.<span class="title function_">of</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">__value</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>functor：实现了 <code>map</code> 函数并遵守一些特定规则的容器类型</p>
</blockquote>
<p>把值装进一个容器，而且只能使用 <code>map</code> 来处理它——是抽象，对函数运用的抽象（当 <code>map</code> 一个函数的时候，我们请求容器来运行这个函数）</p>
<h3 id="Maybe"><a href="#Maybe" class="headerlink" title="Maybe"></a>Maybe</h3><p>另一种 functor：处理空值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Maybe</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__value</span> = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Maybe</span>.<span class="property">of</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Maybe</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Maybe</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isNothing</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="variable language_">this</span>.<span class="property">__value</span> === <span class="literal">null</span> || <span class="variable language_">this</span>.<span class="property">__value</span> === <span class="literal">undefined</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Maybe</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">isNothing</span>()</span><br><span class="line">        ? <span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="literal">null</span>)</span><br><span class="line">    	: <span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">__value</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样我们在使用 <code>map</code> 时代码就不会报错了，而是会得到 <code>Maybe(null)</code></p>
<p><code>Maybe</code> 最常用在那些可能会无法成功返回结果的函数中，通过（人工或自动）抛出 <code>Maybe(null)</code> 可以实现失败时立即切断执行</p>
<p><strong>more pointfree…</strong></p>
<p><code>any_functor_at_all</code> 即为我们上面创建的 <code>Contianer</code>、<code>Maybe</code> 等任意 functor，这样就把 functor 的点记式 map 代理成了 pointfree 的 map 了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, any_functor_at_all</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> any_functor_at_all.<span class="title function_">map</span>(f);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个帮助函数 <code>maybe</code>，用于返回一个自定义的值然后还能继续执行后面的代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b</span></span><br><span class="line"><span class="keyword">var</span> maybe = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">x, f, m</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.<span class="title function_">isNothing</span>() ? x : <span class="title function_">f</span>(m.<span class="property">__value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Either"><a href="#Either" class="headerlink" title="Either"></a>Either</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Left</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__value</span> = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Left</span>.<span class="property">of</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Left</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Left</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Right</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__value</span> = x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Right</span>.<span class="property">of</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Right</span>(x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Right</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Right</span>.<span class="title function_">of</span>(<span class="title function_">f</span>(<span class="variable language_">this</span>.<span class="property">__value</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Right</span>.<span class="title function_">of</span>(<span class="string">&#x27;rain&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">str</span>)&#123; <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>+str; &#125;);</span><br><span class="line"><span class="comment">// Right(&#x27;brain&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Left</span>.<span class="title function_">of</span>(<span class="string">&#x27;rain&#x27;</span>).<span class="title function_">map</span>(<span class="keyword">function</span>(<span class="params">str</span>)&#123; <span class="keyword">return</span> <span class="string">&#x27;b&#x27;</span>+str; &#125;);</span><br><span class="line"><span class="comment">// Left(&#x27;rain&#x27;) !here</span></span><br></pre></td></tr></table></figure>

<p><code>Right</code> 就像个 <code>Container</code>，而 <code>Left</code> 无视了我们的 map 请求</p>
<p><code>Left</code> 可以用来返回错误，让程序短路，比 <code>Maybe(null)</code> 好的是，我们可以在可能错误的地方给 <code>Left</code> 传错误信息了</p>
<p><code>Left</code> 和 <code>Right</code> 是 <code>Either</code> 抽象类型的两个子类，一个（伪）类型签名可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either(String, Number)</span></span><br><span class="line"><span class="comment">// String 表示左边的值是 String，也就是 Left(String)</span></span><br><span class="line"><span class="comment">// Number 表示右边 Right(Number)</span></span><br></pre></td></tr></table></figure>

<p><strong>lift</strong>：一个函数在调用的时候，如果被 <code>map</code> 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数，我们把这个过程叫做 lift。一个比较好的实践是，仍按照普通方式去写（操作普通数据类型的）函数，在必要的时候再通过 lift 变为合适的容器去操作容器类型，这样能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor</p>
<p><strong>帮助函数 <code>either</code></strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// either :: (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c</span></span><br><span class="line"><span class="keyword">var</span> either = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, g, e</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(e.<span class="property">constructor</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Left</span>: <span class="keyword">return</span> <span class="title function_">f</span>(e.<span class="property">__value</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="title class_">Right</span>: <span class="keyword">return</span> <span class="title function_">g</span>(e.<span class="property">__value</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">IO</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">__value</span> = f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable constant_">IO</span>.<span class="property">of</span> = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable constant_">IO</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">IO</span>(_.<span class="title function_">compose</span>(f, <span class="variable language_">this</span>.<span class="property">__value</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>IO</code> 把非纯动作捕获到包裹函数里，目的是延迟这个非纯动作。我们可以认为 <code>IO</code> 包含的是被包裹的执行动作的返回值，而不是包裹函数本身（在 of 函数中可以看出，<code>IO(function() &#123; return x; &#125;)</code> 仅仅是为了延迟执行，其实我们得到的是 <code>IO(x)</code></p>
<p>通过链式调用 <code>map</code>，其实是把传给 <code>map</code> 的函数们压入一个“运行栈”，直到最终调用者调用时才会运行这些（不纯的）函数们</p>
<h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><p><code>Task</code></p>
<h3 id="一点理论"><a href="#一点理论" class="headerlink" title="一点理论"></a>一点理论</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity 同一律</span></span><br><span class="line"><span class="title function_">map</span>(id) === id;</span><br><span class="line"></span><br><span class="line"><span class="comment">// composition 组合律</span></span><br><span class="line"><span class="title function_">compose</span>(<span class="title function_">map</span>(f), <span class="title function_">map</span>(g)) === <span class="title function_">map</span>(<span class="title function_">compose</span>(f, g));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在范畴学中，functor 接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去</p>
<p>可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络</p>
</blockquote>
<p><img src="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/images/functormap.png" alt="functor diagram"></p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><h3 id="pointed-functor"><a href="#pointed-functor" class="headerlink" title="pointed functor"></a>pointed functor</h3><blockquote>
<p>pointed functor 是实现了 <code>of</code> 方法的 functor</p>
</blockquote>
<p>关键是用 <code>of</code> 把任意值丢到容器里然后就可以开始到处使用 <code>map</code> 的能力，像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">any_pointed_functor.<span class="title function_">of</span>(any_value).<span class="title function_">map</span>(f)</span><br></pre></td></tr></table></figure>

<p><code>of</code> 方法不是用来避免 <code>new</code> 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的（我们希望容器类型的任意值都能发生 <code>lift</code>，然后像所有的 functor 那样再 <code>map</code> 出去）</p>
<h3 id="monad"><a href="#monad" class="headerlink" title="monad"></a>monad</h3><blockquote>
<p>monad 是可以变扁（flatten）的 pointed functor</p>
</blockquote>
<p>因为在连续的 functor 传递中，值会被包成 functor(value) -&gt; 传给下一个函数 -&gt; 而下一个函数是普通函数需要用 map 包一下以处理 functor -&gt; 处理完就变成了 functor(functor(value)) -&gt; 那么再下一个函数就需要包两层 map…</p>
<p>例如，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  safeProp :: Key -&gt; &#123;Key: a&#125; -&gt; Maybe a</span></span><br><span class="line"><span class="keyword">var</span> safeProp = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">x, obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Maybe</span>(obj[x]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  safeHead :: [a] -&gt; Maybe a</span></span><br><span class="line"><span class="keyword">var</span> safeHead = <span class="title function_">safeProp</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  firstAddressStreet :: User -&gt; Maybe (Maybe (Maybe Street) )</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = <span class="title function_">compose</span>(</span><br><span class="line">  <span class="title function_">map</span>(<span class="title function_">map</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;street&#x27;</span>))), <span class="title function_">map</span>(safeHead), <span class="title function_">safeProp</span>(<span class="string">&#x27;addresses&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstAddressStreet</span>(</span><br><span class="line">  &#123;<span class="attr">addresses</span>: [&#123;<span class="attr">street</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;Mulburry&#x27;</span>, <span class="attr">number</span>: <span class="number">8402</span>&#125;, <span class="attr">postcode</span>: <span class="string">&quot;WC2N&quot;</span> &#125;]&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Maybe(Maybe(Maybe(&#123;name: &#x27;Mulburry&#x27;, number: 8402&#125;)))</span></span><br></pre></td></tr></table></figure>

<p>为了解决这个一层一层洋葱一样的嵌套，可以在 functor 上定义一个 <code>join</code> 方法，这个 functor 就成为了一个 monad</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Maybe</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">join</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">isNothing</span>() ? <span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="literal">null</span>) : <span class="variable language_">this</span>.<span class="property">__value</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mmo = <span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="string">&#x27;nunchuncks&#x27;</span>));</span><br><span class="line"><span class="comment">// Maybe.of(Maybe.of(&#x27;nunchuncks&#x27;))</span></span><br><span class="line">mmo.<span class="title function_">join</span>();</span><br><span class="line"><span class="comment">// Maybe.of(&#x27;nunchuncks&#x27;) -&gt; flatten!!</span></span><br></pre></td></tr></table></figure>

<p>用 monad 魔法改造上面的 firstAddressStreet 例子，在每次得到嵌套 <code>Maybe</code> 后加一个 <code>join</code> 把它变平</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  join :: Monad m =&gt; m (m a) -&gt; m a</span></span><br><span class="line"><span class="keyword">var</span> join = <span class="keyword">function</span>(<span class="params">mma</span>) &#123; <span class="keyword">return</span> mma.<span class="title function_">join</span>(); &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  firstAddressStreet :: User -&gt; Maybe Street</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = <span class="title function_">compose</span>(join, <span class="title function_">map</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;street&#x27;</span>)), join, <span class="title function_">map</span>(safeHead), <span class="title function_">safeProp</span>(<span class="string">&#x27;addresses&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title function_">firstAddressStreet</span>(</span><br><span class="line">  &#123;<span class="attr">addresses</span>: [&#123;<span class="attr">street</span>: &#123;<span class="attr">name</span>: <span class="string">&#x27;Mulburry&#x27;</span>, <span class="attr">number</span>: <span class="number">8402</span>&#125;, <span class="attr">postcode</span>: <span class="string">&quot;WC2N&quot;</span> &#125;]&#125;</span><br><span class="line">);</span><br><span class="line"><span class="comment">// Maybe(&#123;name: &#x27;Mulburry&#x27;, number: 8402&#125;)</span></span><br></pre></td></tr></table></figure>

<h3 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h3><p>上面的例子中包含一种模式：我们总是在紧跟着 <code>map</code> 的后面调用 <code>join</code>。我们可以把这个行为抽象到一个叫做 <code>chain</code> 的函数中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  chain :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b</span></span><br><span class="line"><span class="keyword">var</span> chain = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, m</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m.<span class="title function_">map</span>(f).<span class="title function_">join</span>(); <span class="comment">// or compose(join, map(f))(m)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>chain</code> 也叫作 <code>&gt;&gt;=</code> （读作 bind）或者 <code>flatMap</code>，重构一下上面的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map/join</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = <span class="title function_">compose</span>(join, <span class="title function_">map</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;street&#x27;</span>)), join, <span class="title function_">map</span>(safeHead), <span class="title function_">safeProp</span>(<span class="string">&#x27;addresses&#x27;</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// chain</span></span><br><span class="line"><span class="keyword">var</span> firstAddressStreet = <span class="title function_">compose</span>(<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;street&#x27;</span>)), <span class="title function_">chain</span>(safeHead), <span class="title function_">safeProp</span>(<span class="string">&#x27;addresses&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>因为 <code>chain</code> 可以轻松嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 序列（sequence）和 变量赋值（variable assignment）。像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Maybe</span>.<span class="title function_">of</span>(<span class="literal">null</span>).<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;address&#x27;</span>)).<span class="title function_">chain</span>(<span class="title function_">safeProp</span>(<span class="string">&#x27;street&#x27;</span>));</span><br><span class="line"><span class="comment">// Maybe(null)</span></span><br></pre></td></tr></table></figure>

<p>使用插入式的 <code>chain</code>，避免了 <code>compose</code> 时还需要几个帮助函数</p>
<p>记住：返回的如果是“普通”值就用 <code>map</code>，如果是 <code>functor</code> 就用 <code>chain</code></p>
<h3 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 结合律</span></span><br><span class="line"><span class="title function_">compose</span>(join, <span class="title function_">map</span>(join)) == <span class="title function_">compose</span>(join, join)</span><br></pre></td></tr></table></figure>

<p><img src="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/images/monad_associativity.png" alt="monad associativity law"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三角同一律</span></span><br><span class="line"><span class="title function_">compose</span>(join, <span class="keyword">of</span>) == <span class="title function_">compose</span>(join, <span class="title function_">map</span>(<span class="keyword">of</span>)) == id</span><br></pre></td></tr></table></figure>

<p><img src="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/images/triangle_identity.png" alt="monad identity law"></p>
<h2 id="Applicative-Functor"><a href="#Applicative-Functor" class="headerlink" title="Applicative Functor"></a>Applicative Functor</h2><blockquote>
<p><code>ap</code> 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。</p>
</blockquote>
<p>比如我们想让两个 <code>Container</code> 的值相加，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样是行不通的, 因为 2 和 3 都藏在 Container 里</span></span><br><span class="line"><span class="title function_">add</span>(<span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">2</span>), <span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">3</span>));</span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用可靠的 map 函数, 得到一个局部调用的 add(2)</span></span><br><span class="line"><span class="keyword">var</span> container_of_add_2 = <span class="title function_">map</span>(add, <span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">2</span>));</span><br><span class="line"><span class="comment">// Container(add(2))</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">2</span>).<span class="title function_">chain</span>(<span class="keyword">function</span>(<span class="params">two</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">3</span>).<span class="title function_">map</span>(<span class="title function_">add</span>(two));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>ap 版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Container</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ap</span> = <span class="keyword">function</span>(<span class="params">other_container</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> other_container.<span class="title function_">map</span>(<span class="variable language_">this</span>.<span class="property">__value</span>);</span><br><span class="line">    <span class="comment">// this.__value 是一个函数, 接受另一个 functor 作为参数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样使用</span></span><br><span class="line"><span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="title function_">add</span>(<span class="number">2</span>)).<span class="title function_">ap</span>(<span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">3</span>)); <span class="comment">// Container(5)</span></span><br><span class="line"><span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">2</span>).<span class="title function_">map</span>(add).<span class="title function_">ap</span>(<span class="title class_">Container</span>.<span class="title function_">of</span>(<span class="number">3</span>)); <span class="comment">// Container(5)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>applicative functor 是实现了 <code>ap</code> 方法的 pointed functor</p>
</blockquote>
<p>一个特性：<code>map</code> 一个 <code>f</code> 等价于 <code>ap</code> 一个值为 <code>f</code> 的 functor</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F.<span class="title function_">of</span>(x).<span class="title function_">map</span>(f) == F.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(F.<span class="title function_">of</span>(x))</span><br></pre></td></tr></table></figure>

<p>applicative functor 可以使几个（独立的不需要依赖顺序的）函数同时执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Http.get :: String -&gt; Task Error HTML</span></span><br><span class="line"><span class="keyword">var</span> renderPage = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">destions, events</span>) &#123; <span class="comment">/* render page */</span> &#125;);</span><br><span class="line"><span class="title class_">Task</span>.<span class="title function_">of</span>(renderPage).<span class="title function_">ap</span>(<span class="title class_">Http</span>.<span class="title function_">get</span>(<span class="string">&#x27;/destinations&#x27;</span>)).<span class="title function_">ap</span>(<span class="title class_">Http</span>.<span class="title function_">get</span>(<span class="string">&#x27;/events&#x27;</span>))</span><br><span class="line"><span class="comment">// 两个 HTTP 请求会同时执行，当两者的响应都返回之后 renderPage 才会被调用</span></span><br><span class="line"><span class="comment">// 是使用局部调用的函数来达成上述结果的，所以必须保证 renderPage 是 curry 函数（没想明白！）</span></span><br><span class="line"><span class="comment">// 调用了两次 ap，每次调用中 renderPage 就收到一个参数然后运行，直到所有的参数都传进来它也就执行完毕了</span></span><br></pre></td></tr></table></figure>

<h3 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liftA2 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, functor1, functor2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> functor1.<span class="title function_">map</span>(f).<span class="title function_">ap</span>(functor2);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> liftA3 = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">f, functor1, functor2, functor3</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> functor1.<span class="title function_">map</span>(f).<span class="title function_">ap</span>(functor2).<span class="title function_">ap</span>(functor3);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// liftA4, etc...</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>让那些小代码块发生 lift，成为 applicative functor 中的一员</p>
</blockquote>
<p>一个实际用例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// checkEmail :: User -&gt; Either String Email</span></span><br><span class="line"><span class="comment">// checkName :: User -&gt; Either String String</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createUser :: Email -&gt; String -&gt; IO User</span></span><br><span class="line">ver createUser = <span class="title function_">curry</span>(<span class="keyword">function</span>(<span class="params">email, name</span>) &#123; <span class="comment">/* creating */</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Either</span>.<span class="title function_">of</span>(createUser).<span class="title function_">ap</span>(<span class="title function_">checkEmail</span>(user)).<span class="title function_">ap</span>(<span class="title function_">checkName</span>(user));</span><br><span class="line"></span><br><span class="line"><span class="title function_">liftA2</span>(createUser, <span class="title function_">checkEmail</span>(user), <span class="title function_">checkName</span>(user));</span><br></pre></td></tr></table></figure>

<h3 id="衍生函数"><a href="#衍生函数" class="headerlink" title="衍生函数"></a>衍生函数</h3><p><code>of/ap</code> &#x3D; <code>map</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">constructor</span>.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>chain</code> -&gt; functor applicative（但会失去 <code>ap</code> 并行的能力）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">map</span> = <span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> m.<span class="title function_">chain</span>(<span class="keyword">function</span>(<span class="params">a</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="property">constructor</span>.<span class="title function_">of</span>(<span class="title function_">f</span>(a));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">X.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">ap</span> = <span class="keyword">function</span>(<span class="params">other</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">chain</span>(<span class="keyword">function</span>(<span class="params">f</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> other.<span class="title function_">map</span>(f);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定律"><a href="#定律" class="headerlink" title="定律"></a>定律</h3><ul>
<li><p>applicative functor 是组合关闭（closed under composition）的，意味着 <code>ap</code> 永远不会改变容器类型</p>
</li>
<li><p>同一律（identity）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(id).<span class="title function_">ap</span>(v) == v</span><br><span class="line"><span class="title function_">map</span>(id) == id</span><br></pre></td></tr></table></figure>
</li>
<li><p>同态（homomorphism）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(f).<span class="title function_">ap</span>(A.<span class="title function_">of</span>(x)) == A.<span class="title function_">of</span>(<span class="title function_">f</span>(x))</span><br></pre></td></tr></table></figure>

<p>同态就是一个能够保持结构的映射，实际上，functor 就是一个在不同范畴间的同态，因为 functor 在经过映射之后保持了原始范畴的结构</p>
</li>
<li><p>互换（interchange）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="title function_">ap</span>(A.<span class="title function_">of</span>(x)) == A.<span class="title function_">of</span>(<span class="keyword">function</span>(<span class="params">f</span>) &#123; <span class="keyword">return</span> <span class="title function_">f</span>(x) &#125;).<span class="title function_">ap</span>(v)</span><br></pre></td></tr></table></figure>
</li>
<li><p>组合（composition）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="title function_">of</span>(compose).<span class="title function_">ap</span>(u).<span class="title function_">ap</span>(v).<span class="title function_">ap</span>(w) == u.<span class="title function_">ap</span>(v.<span class="title function_">ap</span>(w));</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/04/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AF%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E5%9B%BE%E8%AF%B4%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">读书笔记-图说设计模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-30 13:35:00" itemprop="dateCreated datePublished" datetime="2020-04-30T13:35:00+08:00">2020-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:36:15" itemprop="dateModified" datetime="2023-08-23T01:36:15+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://design-patterns.readthedocs.io/zh_CN/latest/">图说设计模式</a> 一书的读书笔记</p>
</blockquote>
<h2 id="看懂UML类图和时序图"><a href="#看懂UML类图和时序图" class="headerlink" title="看懂UML类图和时序图"></a>看懂UML类图和时序图</h2><h3 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h3><p>其中用箭头表示的类之间的关系有以下六种</p>
<table>
<thead>
<tr>
<th>关系</th>
<th>箭头</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>泛化 generalization</td>
<td>空心箭头实线</td>
<td>继承（is-a）非抽象类，A-&gt;B &#x3D; A继承自B</td>
</tr>
<tr>
<td>实现 realize</td>
<td>空心箭头虚线</td>
<td>继承（is-a）抽象类，A-&gt;B &#x3D; A继承自B</td>
</tr>
<tr>
<td>聚合 aggregation</td>
<td>空心菱形箭头实线</td>
<td>表示对象实体之间的关系，A-&gt;B &#x3D; A聚合到B上 &#x3D; B由A组成</td>
</tr>
<tr>
<td>组合 composition</td>
<td>实心菱形箭头实现</td>
<td>与聚合同样语义，但是不同的是聚合里整体和部分不是强依赖的，整体不存在了部分仍然存在；而组合里整体不存在了部分也跟着消失</td>
</tr>
<tr>
<td>关联 association</td>
<td>直线</td>
<td>描述对象间的结构关系，是一种静态的、天然的结构，默认不强调方向。通常实现为成员变量</td>
</tr>
<tr>
<td>依赖 dependency</td>
<td>带箭头的虚线</td>
<td>描述一个对象在运行时会用到另一个对象的关系，临时性，应该总是保持单向依赖。通常实现为类构造方法以及类方法的传入参数</td>
</tr>
</tbody></table>
<h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>一个类只负责一个功能领域中的相应职责</p>
<p>专注降低类的复杂度，实现类要职责单一</p>
<h3 id="开放关闭原则"><a href="#开放关闭原则" class="headerlink" title="开放关闭原则"></a>开放关闭原则</h3><p>设计要对扩展开放，对修改关闭</p>
<p>所有面向对象原则的核心</p>
<p>关键：系统的抽象化设计</p>
<h3 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h3><p>所有引用基类（父类）的地方都必须能透明地使用其子类的对象、</p>
<p>实现开闭原则的重要方式之一，设计不要破坏继承关系</p>
<p>因此尽量使用基类类型定义对象，而在运行时再确定其子类类型，用子类对象来替换父类对象</p>
<h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p>抽象不应该依赖于细节，细节应当依赖于抽象</p>
<p>系统抽象化的具体实现，是面向对象设计的主要实现机制之一</p>
<p>要求面向接口编程，不针对具体实现编程</p>
<p>在代码中传递参数时或在关联关系中，尽量引用高层的抽象基类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明、以及数据类型的转换等，而不要用具体类做这些事情</p>
<p>这样一来，如果系统发生变化，只需对抽象层进行扩展，而不必修改系统现有的业务逻辑，从而满足开闭原则的要求</p>
<p>目标：开闭原则，基础：里式代换，手段：依赖倒置</p>
<h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口</p>
<p>客户需要什么样的接口，就提供什么样的接口，不需要的就删除掉</p>
<p>类之间的依赖关系应建立在最小接口上，也就是说接口要尽量细化，同时接口中的方法应该尽量少，职责要尽可能单一</p>
<p>实际使用时要注意控制接口的粒度，如果太小会导致系统中接口泛滥不利于维护，太大又违反接口隔离原则，灵活性较差。一般而言，接口中仅包含为某一类客户定制的方法即可</p>
<h3 id="迪米特原则（最小知识原则）"><a href="#迪米特原则（最小知识原则）" class="headerlink" title="迪米特原则（最小知识原则）"></a>迪米特原则（最小知识原则）</h3><p>一个软件实体应当尽可能少地与其他实体发生相互作用</p>
<p>要求当修改系统的某一个模块时，要尽量少地影响其他模块，从而使类与类之间保持松散的耦合关系，使系统扩展相对容易</p>
<p>“不要和陌生人说话，只与你的直接朋友通信”：</p>
<ul>
<li>一个对象的朋友包括：this；以参数形式传入到当前对象方法中的对象；当前对象的成员对象；如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；当前对象所创建的对象</li>
<li>如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过引入一个合理的第三者转发这个调用</li>
<li>划分上：应当尽量创建松耦合的类</li>
<li>结构设计上：每一个类都应当尽量降低其成员变量和成员函数的访问权限</li>
<li>设计上：只要有可能，一个类型应当设计成不变类</li>
<li>对其他类的引用上：一个对象对其他对象的引用应当降到最低</li>
</ul>
<h3 id="组合复用原则"><a href="#组合复用原则" class="headerlink" title="组合复用原则"></a>组合复用原则</h3><p>在软件设计中，尽量使用组合&#x2F;聚合（has-a）而不是继承（is-a）达到代码复用的目的</p>
<p>因为继承使得基类与子类有较强的耦合性，通常情况下基类的内部细节对子类来说是可见的，这样基类的实现细节会暴露给子类，破坏了系统的封装性</p>
<h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>对类的实例化过程进行抽象，将对象的创建和对象的使用分离</p>
<p>外界对于这些对象只需要知道它们共同的接口，而不清楚具体的实现细节，使得整个系统的设计更加符合单一职责原则</p>
<h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>专门定义一个工厂类，通过传入的参数不同返回不同类的实例（被创建的实例通常都具有共同的父类）</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg" alt="../_images/SimpleFactory.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Factory 工厂：负责实现创建所有实例的内部逻辑</li>
<li>Product 抽象产品：所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li>
<li>ConcreteProduct 具体产品角色：创建目标，所有创建的对象都充当这个角色的某个具体类的实例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">    <span class="title function_">createProduct</span>(<span class="params">proname</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proname === <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>()</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proname === <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>() </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li><p>要点：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无需知道其创建细节</p>
</li>
<li><p>优点：将对象的创建和对象本身业务处理分离，将对象的创建交给专门的工厂类负责</p>
</li>
<li><p>最大的问题：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则相违背；而且产品较多时工厂方法代码将会非常复杂</p>
</li>
<li><p>适用情况：工厂类负责创建的对象比较少；客户端只需知道传入工厂类的参数，对于如何创建对象不关心</p>
<p>（实际操作中还可以把调用时传入的参数存在 xml 等配置文件中，修改参数时无需修改任何源代码）</p>
</li>
</ul>
<h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>对上述简单工厂模式进行修改，不再设计一个工厂类负责<em>所有</em>产品的创建，而是将具体产品的创建过程交给专门的工厂子类去完成。</p>
<p>即，先定义一个抽象的工厂类，再定义具体的工厂子类生成具体的产品</p>
<p>这种抽象化的结果使这种结构可以在不修改现有抽象&#x2F;具体工厂类的情况下引进新的产品，只需为新产品新建一个具体工厂类</p>
<p>更符合开闭原则</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg" alt="../_images/FactoryMethod.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Product 抽象产品</li>
<li>ConcreteProduct 具体产品</li>
<li>Factory 抽象工厂</li>
<li>ConcreteFactory 具体工厂</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Factory</span>&#123;</span><br><span class="line">    <span class="title function_">factoryMethod</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProduct</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>基于工厂角色和产品角色的多态性设计，使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。又被称为多态工厂模式，因为所有的具体工厂类都具有同一抽象父类</li>
<li>优点：符合开闭原则，系统中加入新产品时无需修改抽象工厂和抽象产品&#x2F;客户端&#x2F;其他的具体工厂和具体产品，只需新增一个具体工厂和具体产品</li>
<li>缺点：系统中类的数量会比较多，增加了系统复杂度；引入抽象层增加了理解难度</li>
<li>适用情况：<ul>
<li>一个类不知道它所需要的对象的类，只需知道创建具体产品的工厂类</li>
<li>一个类通过其子类来指定创建哪个对象，符合多态性和里式替换原则</li>
<li>客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定</li>
</ul>
</li>
</ul>
<h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote>
<p>产品等级结构：产品的继承结构</p>
<p>产品族：由同一个工厂生产的，位于不同产品等级结构中的一组产品</p>
</blockquote>
<p>当系统所提供的工厂所需生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构中属于不同类型的具体产品时需要使用抽象工厂模式</p>
<p>工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg" alt="../_images/AbatractFactory.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Product 具体产品</li>
<li>AbstractProduct 抽象产品</li>
<li>ConcreteFactory 具体工厂</li>
<li>AbstractFactory 抽象工厂</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createProductA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA1</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createProductB</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB1</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="title function_">createProductA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductA2</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">createProductB</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProductB2</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（A&#x2F;B代表一个产品族，抽象工厂可以处理多个产品族，而工厂方法只能处理一个产品族）</p>
<p><strong>分析：</strong></p>
<ul>
<li>优点：隔离了具体类的生成，使得客户并不需要知道什么被创建；每次可以通过具体工厂类创建一个产品族中的多个对象，增加或替换产品族比较方便</li>
<li>缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对开闭原则的支持呈现倾斜性（即增加新的产品族比较方便，但增加新的产品等级结构很复杂）</li>
<li>适用情况：<ul>
<li>系统中有多个产品族，每次只使用其中某一族；</li>
<li>属于同一个产品族的产品将在一起使用；</li>
<li>系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现</li>
</ul>
</li>
</ul>
<h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>复杂对象（汽车），有很多属性（汽车部件 ），对于用户而言无需知道这些细节，只想使用一辆完整汽车，因此将建造（组合部件）过程外部化到一个称作建造者的对象中</p>
<p>用户只需指定复杂对象的类型和内容就可以构建它们，不需要知道内部的具体构建细节</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Builder.jpg" alt="../_images/Builder.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Builder 抽象建造者：定义产品的创建方法和返回方法</li>
<li>ConcreteBuilder 具体建造者</li>
<li>Director 指挥者：隔离客户与生产过程，控制产品的生成过程。指挥者针对抽象建造者编程，客户只需要知道具体建造者的类型，即可通过指挥者调用建造者的相关方法，返回一个完整的产品对象</li>
<li>Product 产品</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Builder</span> &#123;</span><br><span class="line">    <span class="title function_">buildPartA</span>(<span class="params"></span>) &#123;</span><br><span class="line">        m_prod.<span class="title function_">setA</span>(<span class="string">&quot;A Style &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">buildPartB</span>(<span class="params"></span>) &#123;</span><br><span class="line">        m_prod.<span class="title function_">setB</span>(<span class="string">&quot;B Style &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">buildPartC</span>(<span class="params"></span>) &#123;</span><br><span class="line">        m_prod.<span class="title function_">setC</span>(<span class="string">&quot;C Style &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Diector</span> &#123;</span><br><span class="line">    <span class="title function_">construct</span>(<span class="params"></span>) &#123;</span><br><span class="line">        m_pbuilder.<span class="title function_">buildPartA</span>()</span><br><span class="line">        m_pbuilder.<span class="title function_">buildPartB</span>()</span><br><span class="line">        m_pbuilder.<span class="title function_">buildPartC</span>()</span><br><span class="line">        <span class="keyword">return</span> m_pbuilder.<span class="title function_">getResult</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setBuilder</span>(<span class="params">builder</span>) &#123;</span><br><span class="line">        m_pbuilder = builder</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用户调用</span></span><br><span class="line"><span class="keyword">const</span> builder = <span class="keyword">new</span> <span class="title class_">ConcreteBuilder</span>()</span><br><span class="line"><span class="keyword">const</span> director = <span class="keyword">new</span> <span class="title class_">Diector</span>()</span><br><span class="line">director.<span class="title function_">setBuilder</span>(builder)</span><br><span class="line"><span class="keyword">const</span> product = director.<span class="title function_">construct</span>()</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象；</li>
<li>具体建造者之间相对独立，用户使用不同的具体建造者即可得到不同的产品对象；</li>
<li>可以更加精细地控制产品的创建过程；</li>
<li>增加新的具体建造者无需修改原有类库的代码，指挥者类针对的是抽象建造者编程，符合开闭原则</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>建造者模式适用于产品比较相似的情况，产品之间的差异性很大时不适合使用建造者模式；</li>
<li>如果产品内部变化复杂，可能会导致需要定义很多具体建造者来实现这种变化，导致系统变得很庞大</li>
</ul>
</li>
<li><p>适用环境：</p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，通常包含多个成员属性；</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序；</li>
<li>对象的创建过程独立于创建该对象的类，引入指挥者；</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品</li>
</ul>
</li>
<li><p>简化：如果系统中只需一个具体建造者时，可省略抽象建造者，省略指挥者</p>
</li>
<li><p>与抽象工厂模式比较：</p>
<ul>
<li>建造者模式返回一个组装好的完成产品，而抽象工厂模式返回一系列相关的产品（产品族）；</li>
<li>抽象工厂中客户端需要实例化工厂类然后调用工厂方法取得所需对象，建造者模式可以不调用建造者的相关方法，而是通过指挥者类；</li>
<li>抽象工厂模式：汽车配件生产工厂，生产一个产品族的产品；建造者模式：汽车组装工厂，返回一辆完整的汽车</li>
</ul>
</li>
</ul>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>保证一个类只有一个实例并且这个实例易于被访问：让类自身负责保存它的唯一实例，这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法</p>
<p>要点：某个类只能有一个实例；它必须自行创建这个实例；它必须自行向整个系统提供这个实例</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Singleton.jpg" alt="../_images/Singleton.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Singleton 单例</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最简单的单例模式</span></span><br><span class="line"><span class="keyword">let</span> timeTool = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;处理时间工具库&#x27;</span>,</span><br><span class="line">    <span class="attr">getISODate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;,</span><br><span class="line">    <span class="attr">getUTCDate</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最简单的单例模式实现，用 js 的对象字面量实例化一个对象，因为 let 不允许重复声明所以 <code>timeTool</code> 不能被重新覆盖</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 惰性单例</span></span><br><span class="line"><span class="comment">// 只在需要的时候进行单例的创建</span></span><br><span class="line"><span class="comment">// 如果再次调用，返回的永远是第一次实例化的单例对象</span></span><br><span class="line"><span class="keyword">let</span> timeTool = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> _instance = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">init</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 私有变量</span></span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line">        <span class="comment">// 公用属性和方法</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;处理时间工具库&#x27;</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getISODate</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> now.<span class="title function_">toISOString</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">getUTCDate</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> now.<span class="title function_">toUTCString</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_instance) &#123;</span><br><span class="line">            _instance = <span class="keyword">new</span> <span class="title function_">init</span>()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// singleton in es6</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingletonApple</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, creator, products</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">creator</span> = creator</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">products</span> = products</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">getInstance</span>(<span class="params">name, creator, products</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">instance</span>) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">instance</span> = <span class="keyword">new</span> <span class="title class_">SingletonApple</span>(name, creator, products)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">instance</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>es6 的 export 出的实例即是单例</p>
<p><strong>分析：</strong></p>
<ul>
<li>优点：提供了对唯一实例的受控访问并可以节约系统资源</li>
<li>缺点：因为缺少抽象层而难以扩展，且单例类职责过重</li>
</ul>
<h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>描述如何将类或者对象结合在一起形成更大的结构</p>
<p>分为类结构型模式和对象结构型模式</p>
<ul>
<li>类结构型模式：关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系</li>
<li>对象结构型模式：关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。（组合复用原则：在系统中应尽量使用关联关系来替代继承关系）</li>
</ul>
<h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将一个借口转换成客户希望的另一个接口（现有的类可以满足客户类的功能需要，但接口不一定是客户类所期望的）</p>
<p>适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用</p>
<p>对象适配器：</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter.jpg" alt="../_images/Adapter.jpg"></p>
<p>类适配器：</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Adapter_classModel.jpg" alt="../_images/Adapter_classModel.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Target 目标抽象类</li>
<li>Adapeter 适配器类</li>
<li>Adaptee 适配者类（被适配的原对象类）</li>
<li>Client 客户类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adapter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Target</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">adaptee</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pAdaptee</span> = adaptee</span><br><span class="line">        <span class="comment">// 准确来说，这个 m_pAdaptee 应当定义为私有变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pAdaptee</span>.<span class="title function_">specificRequest</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无需修改原有代码</li>
<li>增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性</li>
<li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”</li>
<li>类适配器：因为适配器是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强</li>
<li>对象适配器：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>类适配器：对于不支持多重继承的语言，一次最多只能适配一个适配者类，而且 Target 只能为抽象类不能为具体类，其使用有一定的局限性</li>
<li>对象适配器：想置换适配者类的方法不容易</li>
</ul>
</li>
<li><p>扩展：默认适配器模式</p>
<p>先设计一个抽象类实现接口，并为该接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，适用于一个接口不想使用其所有的方法的情况</p>
</li>
</ul>
<h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>将抽象部分与它的实现部分分离（由原来的继承关系改为关联关系，强关联改为弱关联），使他们都可以独立地变化</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Bridge.jpg" alt="../_images/Bridge.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Abstraction 抽象类：定义一个实现类接口类型的对象并可以维护该对象</li>
<li>RefinedAbstraction 扩充抽象类：扩充抽象类定义的接口，实现在抽象类中定义的抽象业务方法</li>
<li>Implementor 实现类接口：仅提供基本操作</li>
<li>ConcreteImplementor 具体实现类：实现了实现类的接口并具体实现它，在不同的具体实现类中提供基本操作的不同实现</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于 JavaScript 不支持抽象类，所以没有 Abstraction 和 Implementor</span></span><br><span class="line"><span class="comment">// 下面实现 RefinedAbstraction 和 ConcreteImplementor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RefinedAbstraction</span> &#123;</span><br><span class="line">    <span class="title function_">constuctor</span>(<span class="params">imp</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pImp</span> = imp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">operation</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pImp</span>.<span class="title function_">operationImp</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteImplementor</span> &#123;</span><br><span class="line">    <span class="title function_">operationImp</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 具体实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li><p>优点：</p>
<ul>
<li>比如有两个变化维度的系统，采用桥接模式可以提高可扩充性（任意扩展一个维度都不需要修改原有系统）；</li>
<li>有时类似多继承，但多继承方案违背了类的单一职责原则，复用性比较差，且类的个数非常庞大</li>
</ul>
</li>
<li><p>缺点：增加系统的理解与设计难度，要求针对抽象进行设计与编程</p>
</li>
<li><p>适用：</p>
<ul>
<li>抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，则可以用桥接模式使它们在抽象层建立一个关联关系</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展</li>
<li>系统需要对抽象化角色和实现化角色进行动态耦合</li>
</ul>
</li>
</ul>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>动态地给一个对象增加一些额外的职责，不需要创造更多子类而将对象的功能加以扩展‘</p>
<p>方式与适配器模式相同，把继承关系变成关联关系</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Decorator.jpg" alt="../_images/Decorator.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Component 抽象构件</li>
<li>ConcreteComponent 具体构件</li>
<li>Decorator 抽象装饰类</li>
<li>ConcreteDecorator 具体装饰类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteDecorator</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">component</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pComponent</span> = component</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">addBehavior</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//增加新行为</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">operation</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pComponent</span>.<span class="title function_">operation</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">addBehavior</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>优点：比继承更灵活，可以通过不同的装饰类以及这些装饰类的排列组合，得到很多种不同行为的对象；修改时只需增加新的 ConcreteComponent 和 ConcreteDecorator，符合开闭原则</li>
<li>缺点：会产生很多小对象，他们之间的区别在于相互连接的方式不同，而不是它们的类或者属性值不同，增加系统复杂度，加大理解难度；更灵活也就更容易出错，难以排查</li>
<li>使用时尽量保持 ConcreteComponent 作为一个轻类，不要包含太多的逻辑和状态，而是通过装饰类对其进行扩展</li>
</ul>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供了一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Facade.jpg" alt="../_images/Facade.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Facade 外观</li>
<li>SubSystem 子系统</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemA</span> = <span class="keyword">new</span> <span class="title class_">SystemA</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemB</span> = <span class="keyword">new</span> <span class="title class_">SystemB</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemC</span> = <span class="keyword">new</span> <span class="title class_">SystemC</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">wrapOpration</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemA</span>.<span class="title function_">operationA</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemB</span>.<span class="title function_">operationB</span>()</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_SystemC</span>.<span class="title function_">operationC</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>划分子系统符合单一职责原则，而为了使子系统间的通信和相互依赖关系达到最小，就可以引入一个外观对象</li>
<li>是迪米特法则的体现，降低原有系统的复杂度，降低客户类与子系统类的耦合度</li>
<li>优点：<ul>
<li>对客户屏蔽子系统组件，客户代码变得简单</li>
<li>子系统与客户松散耦合</li>
<li>降低大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程</li>
</ul>
</li>
<li>缺点：<ul>
<li>不能很好地限制客户使用子系统类，而如果对客户访问子系统类做太多的限制则减少了可变性和灵活性</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则</li>
</ul>
</li>
<li>扩展：<ul>
<li>多个外观类</li>
<li>不要试图通过外观类为子系统增加新行为</li>
</ul>
</li>
</ul>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>通过共享技术有效地支持大量细粒度对象的复用，系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Flyweight.jpg" alt="../_images/Flyweight.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Flyweight 抽象享元类</li>
<li>ConcreteFlyweight 具体享元类</li>
<li>UnsharedConcreteFlyweight 非共享具体享元类</li>
<li>FlyweightFactory 享元工厂类：维护一个享元池用于存储具有相同内部状态的享元对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlyweightFactory</span> &#123;</span><br><span class="line">    <span class="title function_">getFlyweight</span>(<span class="params">type</span>) &#123;</span><br><span class="line">        <span class="comment">// 伪代码...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">m_mpFlyweight</span>.<span class="title function_">find</span>(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> exist one</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> fw = <span class="keyword">new</span> <span class="title class_">ConcreteFlyweight</span>(type)</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">m_mpFlyweight</span>.<span class="title function_">push</span>(fw)</span><br><span class="line">            <span class="keyword">return</span> fw</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Flyweight</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        intrinsicState = state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">operation</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// do operation</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>核心在于享元工厂类（维护的享元池）</li>
<li>以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态<ul>
<li>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享</li>
<li>外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用时再传入到享元对象内部，一个外部状态与另一个外部状态之间是相互独立的</li>
</ul>
</li>
<li>优点：<ul>
<li>极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份</li>
<li>外部状态相对独立，不会影响内部状态，从而使得享元对象可以在不同环境中被共享</li>
</ul>
</li>
<li>缺点：<ul>
<li>使得系统更加复杂，需要分离出内部状态和外部状态</li>
<li>读取外部状态使得运行时间变长</li>
</ul>
</li>
<li>适用：<ul>
<li>一个系统有大量相同或者相似的对象，这类对象的大量适用造成内存的大量耗费</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中</li>
<li>因为维护享元池会耗费资源，所以应当在多次重复使用享元对象时才值得使用享元模式</li>
</ul>
</li>
<li>扩展：<ul>
<li>单纯享元模式：所有享元对象都是可以共享的，不存在非共享具体享元类</li>
<li>复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但它们可以分解成单纯享元对象，而后者则可以共享</li>
<li>享元工厂类通常只有唯一一个，可以设计成单例</li>
</ul>
</li>
</ul>
<h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用</p>
<p>代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务，或者添加客户需要的额外服务</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Proxy.jpg" alt="../_images/Proxy.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Subject 抽象主题</li>
<li>Proxy 代理主题</li>
<li>RealSubject 真实主题</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pRealSubject</span> = <span class="keyword">new</span> <span class="title class_">RealSubject</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">preRequest</span>() <span class="comment">// 一些其他行为</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pRealSubject</span>.<span class="title function_">request</span>() <span class="comment">// 真正和原对象交互</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">afterRequest</span>() <span class="comment">// 一些其他行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>优点：协调调用者和被调用者，在一定程度上降低了系统的耦合度</li>
<li>缺点：有些类型的代理模式可能会造成请求的处理速度变慢；有些代理的实现比较复杂，需要额外的工作</li>
<li>使用：<ul>
<li>远程（remote）代理：为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中</li>
<li>虚拟（virtual）代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建</li>
<li>Copy-on-Write代理：是虚拟代理的一种，把复制（克隆）操作延迟到只有在客户端真正需要时才执行（因为深克隆是个开销较大的操作，可以使用这个代理让这个操作延迟到只有对象被用到时才被克隆）</li>
<li>保护（Protect or Access）代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限</li>
<li>缓冲（Cache）代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果</li>
<li>防火墙（Firewall）代理：保护目标不让恶意用户接近</li>
<li>同步化（Synchronization）代理：使几个用户能够同时使用一个对象而没有冲突</li>
<li>智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等</li>
</ul>
</li>
</ul>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>将发送者和接受者完全解耦，没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求</p>
<p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Command.jpg" alt="../_images/Command.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Command 抽象命令类</li>
<li>ConcreteCommand 具体命令类</li>
<li>Invoker 调用者</li>
<li>Receiver 接受者</li>
<li>Client 客户类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Receiver</span> &#123;</span><br><span class="line">    <span class="title function_">action</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 定义接收到命令的行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Invoker</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">command</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的 command 是抽象命令接口，发送者针对抽象接口编程</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pCommand</span> = command</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">call</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 发出命令</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pCommand</span>.<span class="title function_">execute</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteCommand</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Command</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">receiver</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pReceiver</span> = receiver</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">execute</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pReceiver</span>.<span class="title function_">action</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>优点：<ul>
<li>降低系统耦合度</li>
<li>新的命令可以很容易地加入到系统中，可以比较容易地设计一个命令队列和宏命令（组合命令），可以方便地实现对请求的 undo 和 redo</li>
</ul>
</li>
<li>缺点：可能会导致系统中有过多的具体命令类</li>
<li>适用：<ul>
<li>系统需要将请求调用者和请求接受者解耦，使得调用者和接受者不直接交互</li>
<li>系统需要在不同的时间指定请求、将请求排队、执行请求</li>
<li>系统需要支持命令的撤掉和恢复操作</li>
<li>系统需要将一组操作组合在一起，即支持宏命令</li>
</ul>
</li>
<li>扩展：宏命令</li>
</ul>
<h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><p>用一个中介对象来封装一系列的对象交互，中介者使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Mediator.jpg" alt="../_images/Mediator.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Mediator 抽象中介者</li>
<li>ConcreteMediator 具体中介者</li>
<li>Colleague 抽象同事类</li>
<li>ConcreteColleague 具体同事类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">// 一些伪代码</span></span><br><span class="line">    <span class="title function_">operation</span>(<span class="params">to, msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_mpColleague</span>.<span class="title function_">find</span>(to).<span class="title function_">receivemsg</span>(msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">registered</span>(<span class="params">colleague</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">m_mpColleague</span>.<span class="title function_">find</span>(colleague)) &#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">m_mpColleague</span>.<span class="title function_">push</span>(colleague)</span><br><span class="line">            colleague.<span class="title function_">setMediator</span>(<span class="variable language_">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteColleague</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Colleague</span> &#123;</span><br><span class="line">    <span class="title function_">setMediator</span>(<span class="params">mediator</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pMediator</span> = mediator</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">sendmsg</span>(<span class="params">to, msg</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pMediator</span>.<span class="title function_">operation</span>(to, msg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">receviemsg</span>(<span class="params">msg</span>) &#123;</span><br><span class="line">        <span class="comment">// 收到消息的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>中介者模式可以使对象之间的关系数量急剧减少，中介者承担两方面职责：中转作用（结构性），协调作用（行为型）</li>
<li>优点：简化对象之间交互，各同事解耦，减少子类生成，可以简化各同事类的设计和实现</li>
<li>缺点：在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护</li>
<li>适用：<ul>
<li>系统中对象存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解</li>
<li>一个对象由于引用了其他很多对象并直接和这些对象通信，导致难以复用该对象</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类，可以通过引入中介者类实现，在中介者中定义对象</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介者类</li>
</ul>
</li>
<li>扩展：<ul>
<li>例如 MVC 结构中的 Controller，负责控制视图对象 View 和模型对象 Model 之间的交互</li>
<li>符合迪米特法则</li>
</ul>
</li>
</ul>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>建立一种对象与对象之间的依赖关系（一对多），一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Obeserver.jpg" alt="../_images/Obeserver.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Subject 目标</li>
<li>ConcreteSubject 具体目标</li>
<li>Observer 观察者</li>
<li>ConcreteObserver 具体观察者</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Subject</span> &#123;</span><br><span class="line">    <span class="title function_">attach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_vtObj</span>.<span class="title function_">push</span>(observer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">detach</span>(<span class="params">observer</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_vtObj</span>.<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">m_vtObj</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">e</span> =&gt;</span> e === observer), <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_vtObj</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="title function_">update</span>(<span class="variable language_">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 改变自身状态</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">notify</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">getState</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 方便 observer 调用取得状态</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcretObserver</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Observer</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_objName</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">update</span>(<span class="params">subject</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_observerState</span> = subject.<span class="title function_">getState</span>()</span><br><span class="line">        <span class="comment">// 一些基于 this.m_objName 和 this.m_observerState 的操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>一个目标可以有多个观察者（用一个数组存），一旦目标状态发生改变，就遍历数组通知所有观察者；观察者收到通知进行自身更新</li>
<li>优点：<ul>
<li>表示层（observer）与数据逻辑层（subject）的分离，定义了稳定的消息更新传递机制，抽象了更新接口，使得可以由各种各样不同的表示层作为具体观察者角色</li>
<li>观察目标和观察者之间抽象耦合</li>
<li>支持广播通信</li>
<li>符合开闭原则</li>
</ul>
</li>
<li>缺点：<ul>
<li>如果一个 subject 有很多直接和间接的 observer 的话，通知所有 observer 会花费很多时间</li>
<li>如果 subject 和 observer 之间存在循环依赖，会发生循环调用</li>
<li>观察者模式没有相应的机制让观察者知道目标对象是怎样发生变化的，而仅仅能知道发生了变化</li>
</ul>
</li>
<li>适用：<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B，B对象的行为将影响C……</li>
</ul>
</li>
<li>扩展：<ul>
<li>MVC：model - subject（被观察的目标），view - observer（观察者），controller - 充当两者之间的中介者 mediator，避免两者直接引用</li>
</ul>
</li>
</ul>
<h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/State.jpg" alt="../_images/State.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Context 环境类：拥有状态的对象，有时候可以充当状态管理器的角色，可以在环境类中对状态进行切换操作。针对抽象状态类进行编程</li>
<li>State 抽象状态类：专门表示对象的状态，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的</li>
<li>ConcreteState 具体状态类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pState</span> = <span class="keyword">new</span> <span class="title class_">ConcreteState</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">changeState</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pState</span> = state</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">request</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pState</span>.<span class="title function_">handle</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteState</span> <span class="keyword">extends</span> <span class="title class_ inherited__">State</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">context</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">context</span> = context</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">handle</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// doing something in state</span></span><br><span class="line">        <span class="comment">// then change state</span></span><br><span class="line">        context.<span class="title function_">changeState</span>(<span class="keyword">new</span> <span class="title class_">ConcreteStateB</span>(<span class="variable language_">this</span>.<span class="property">context</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>优点：<ul>
<li>封装了状态转换规则，状态转换逻辑与状态对象合成一体</li>
<li>枚举可能的状态</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象行为</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数</li>
</ul>
</li>
<li>缺点：<ul>
<li>必然会增加系统类和对象的个数</li>
<li>结构和实现都较为复杂，如果使用不当将导致程序结构和代码的混乱</li>
<li>不符合开闭原则，新增状态需要修改那些负责状态转换的代码，而且修改某个状态类的行为也需要修改对应类的代码</li>
</ul>
</li>
<li>适用：<ul>
<li>对象的行为依赖于它的状态并且可以根据它的状态改变而改变它的相关行为</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强；在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态</li>
</ul>
</li>
<li>扩展：<ul>
<li>多个环境对象共享一个或多个状态对象，需要将这些状态对象定义为环境的静态成员对象</li>
<li>简单状态模式：状态相互独立，状态之间无需进行转换。此时每个状态类都封装与状态相关的操作，而无需关心状态的切换，客户端直接实例状态类然后把状态对象设置到环境类中即可。遵循开闭原则，客户端针对抽象状态类进行编程，增加新的状态类对原有系统也不造成任何影响</li>
<li>可切换状态的状态模式：在切换状态时需要在具体状态类内部调用 context.changeState()，因此状态类与环境类之间还存在关联关系或依赖关系，通过在状态类中引用环境类的对象实现调用。这种模式下增加新的状态类可能会需要修改其他状态类甚至环境类的源代码，否则无法切换</li>
</ul>
</li>
</ul>
<h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化</p>
<p><img src="https://design-patterns.readthedocs.io/zh_CN/latest/_images/Strategy.jpg" alt="../_images/Strategy.jpg"></p>
<p><strong>角色：</strong></p>
<ul>
<li>Context 环境类</li>
<li>Strategy 抽象策略类</li>
<li>ConcreteStrategy 具体策略类</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="title function_">algorithm</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pStrategy</span>.<span class="title function_">algorithm</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">setStrategy</span>(<span class="params">strategy</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">m_pStrategy</span> = strategy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteStrategy</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Strategy</span> &#123;</span><br><span class="line">    <span class="title function_">algorithm</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 具体算法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析：</strong></p>
<ul>
<li>把算法的责任和算法本身分隔开，委派给不同的对象管理。“准备一组算法，并将每一个算法封装起来，使得它们可以互换”</li>
<li>客户端自己决定在什么情况下使用什么具体策略角色，策略模式仅仅封装算法</li>
<li>优点：<ul>
<li>完美支持“开闭原则”，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为</li>
<li>提供管理相关算法族的办法</li>
<li>提供可以替换继承关系的办法</li>
<li>可以避免使用多重条件转移语句</li>
</ul>
</li>
<li>缺点：<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类</li>
<li>将造成很多策略类，可以通过享元模式在一定程度上减少对象的数量</li>
</ul>
</li>
<li>适用：<ul>
<li>如果一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为</li>
<li>在具体策略类中封装算法和相关数据结构，提高算法的保密性和安全性</li>
</ul>
</li>
<li>扩展：策略模式与状态模式<ul>
<li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式</li>
<li>策略模式的环境类自己选择一个具体策略类，具体策略类无需关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系</li>
<li>策略模式客户端需要知道所选的具体策略是哪一个；状态模式客户端无需关心具体状态，环境类的状态会根据用户的操作自动转换</li>
<li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式</li>
</ul>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/04/20/React%E5%85%A5%E9%97%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/20/React%E5%85%A5%E9%97%A8/" class="post-title-link" itemprop="url">笔记React入门</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-20 15:13:00" itemprop="dateCreated datePublished" datetime="2020-04-20T15:13:00+08:00">2020-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:32:57" itemprop="dateModified" datetime="2023-08-23T01:32:57+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="React"><a href="#React" class="headerlink" title="React"></a>React</h1><h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX -&gt; React 元素 -&gt; DOM</p>
<p><code>&#123;&#125;</code> 大括号中可以放置任何有效的 js 表达式</p>
<p>JSX 本质上也是个表达式，编译后会被转为 <code>React.createElement()</code> 这种普通函数调用</p>
<h2 id="元素渲染"><a href="#元素渲染" class="headerlink" title="元素渲染"></a>元素渲染</h2><p>元素是构成 React 应用的最小砖块</p>
<p>元素描述了你在屏幕上想看到的内容，与普通 DOM 不同，React 是开销极小的普通对象，React DOM 会负责更新 DOM 来与 React 元素保持一致（这个更新算法是高效的，只会进行必要的更新）</p>
<p>组件是由元素组成的</p>
<p>React 元素是不可变对象，一旦被创建，就无法更改它的子元素或者属性（代表了某个特定时刻的 UI）。更新 UI 的方式之一是创建一个全新的元素，并将其传入 <code>ReactDOM.render()</code></p>
<h2 id="组件-Props"><a href="#组件-Props" class="headerlink" title="组件 &amp; Props"></a>组件 &amp; Props</h2><p>组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思。</p>
<p>函数组件：参数 props，返回 react 元素</p>
<p>class组件：es6 的 class 语法，在 react 中和函数组件是等效的</p>
<p>纯函数：不更改入参，且多次情况下调用相同的入参始终返回相同的结果</p>
<p><strong>所有的 React 组件都必须像纯函数一样保护它们的 props 不被更改</strong></p>
<h2 id="State-生命周期"><a href="#State-生命周期" class="headerlink" title="State &amp; 生命周期"></a>State &amp; 生命周期</h2><p>state：私有的，完全受控于当前组件</p>
<p><code>this.props</code> 和 <code>this.state</code> 是 React 本身设置的有特殊含义的属性，但其实也可以向 class 中随意添加（不参与数据流的）其他字段</p>
<p>生命周期方法：</p>
<ul>
<li><code>componentDidMount()</code> &#x3D; vue 的 mounted</li>
<li><code>componentWillUnmount()</code> &#x3D; vue 的 beforeDestory</li>
</ul>
<p>更新 UI 的方式之二：state 里面（通过<code>setState()</code>）修改数据，从而 React 能够知道state 变化，每次更新时都调用组件的 render 方法</p>
<p>正确使用 State：</p>
<ul>
<li><p>除了在构造函数中其他地方都不要直接给 state 赋值的方式修改它，应该使用 <code>setState()</code></p>
</li>
<li><p>state 的更新可能是异步的，React 可能会把多个 <code>setState()</code> 调用合并成一个调用（和 vue 类似）</p>
<p>所以不要依赖 <code>this.state</code> 或 <code>this.props</code> 的值来更新下一个状态，如果需要，可以在 <code>setState()</code> 中传入一个函数 <code>(state, props) =&gt; &#123;&#125;</code> ，其中 state 是上一个 state，props 是此次更新时被应用的 props</p>
</li>
<li><p>state的更新会被合并，<code>setState()</code> 传入的对象会 assign 到现有的 state 上，同样也是浅合并</p>
</li>
</ul>
<p><strong>数据是向下流动的</strong>，state 只能由本组件访问，可以通过 props 的方式向下传递，单向数据流</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>this 要手动添加绑定（解释可以参考 <a target="_blank" rel="noopener" href="https://blog.csdn.net/corner2030/article/details/97802475?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1">这一篇</a>）</p>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><ul>
<li>if</li>
<li>可以用变量储存元素</li>
<li>利用 js 的 <code>&amp;&amp;</code> 运算符</li>
<li>利用 js 的三目运算符</li>
</ul>
<p>阻止组件渲染：<code>render</code> 返回 null</p>
<h2 id="列表-Key"><a href="#列表-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h2><p>渲染多个组件：构建元素数组，然后将数组加入 JSX 中</p>
<p>key（同 vue）：</p>
<ul>
<li>在数组的上下文中指定（通常是在 <code>map</code> 方法中的元素）</li>
<li>key 只是在兄弟节点之间必须唯一</li>
</ul>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>受控组件：state 是唯一数据源（与 v-model 类似，表单项的 <code>value</code> 赋值为 <code>state</code> 中的值，输入事件指定一个函数，函数内使用 <code>setState()</code> 改变 state -&gt; 从而使得 value 值发生改变）</p>
<p>如果在受控组件上把 value 指定成了 prop 则会阻止用户更改输入</p>
<p>但是对于像 <code>&lt;input type=&quot;file&quot; /&gt;</code> 这种 value 只读的组件，属于非受控组件</p>
<h2 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h2><p>将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中</p>
<p>和受控组件一样，父组件提供 value 和 onChange（或者任何命名），作为 props 传递给子组件，子组件只负责展示+监听值变化时通过调用父组件传来的处理函数把值传上去</p>
<p>任何可变数据应当只有一个相对应的唯一数据源，应当依靠自上而下的数据流，而不是尝试在不同组件间同步 state</p>
<p>如果某些数据可以由 props 或 state 推导得出，那么它就不应该存在于 state 中</p>
<h2 id="组合-vs-继承"><a href="#组合-vs-继承" class="headerlink" title="组合 vs 继承"></a>组合 vs 继承</h2><ul>
<li><p>包含关系：组合</p>
<p>props.children（类似于 vue 匿名 slot）；或者自己命名 props（类似于 vue 具名 slot）</p>
</li>
<li><p>特例关系：props</p>
<p>通过给一般组件指定 props 来定制特殊组件</p>
</li>
<li><p>继承关系：React 不需要继承来构建组件层次，props 和组合能够完成组件间复用 ui（包括外观和行为），如果需要复用非 ui 的功能，建议将其提取为一个单独的 js 模块，组件可以直接 import 而无需通过 extend 继承它们</p>
</li>
</ul>
<h2 id="React-哲学"><a href="#React-哲学" class="headerlink" title="React 哲学"></a>React 哲学</h2><ol>
<li><p>将设计好的 UI 划分为组件层级</p>
<p>圈出每个组件，并以合适的名称命名</p>
<p>划分组件的过程中，根据单一功能原则判定组件的范围</p>
</li>
<li><p>用 React 创建一个静态版本</p>
<p>先用已有的数据模型渲染一个不包含交互功能的 UI（编写一个应用的静态版本时，往往需要编写大量代码而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节而不需要编写太多代码）</p>
<p>只使用 props，完全不应该使用 state 构建静态版本（state 代表了随时间会产生变化的数据，应当仅在实现交互时使用）</p>
<p>这些组件目前只需提供 <code>render()</code> 方法用于渲染，最顶层的组件通过 props 接受数据模型，<strong>单向数据流</strong></p>
</li>
<li><p>确定 UI state 的最小（且完整）表示</p>
<p>DRY: Don’t Repeat Yourself，只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生</p>
<p>非父组件 props 传递来的、随着时间推移改变的、不能根据其他 state 或 props 计算出该数据的值 &#x3D;&gt; 是 state</p>
</li>
<li><p>确定 state 放置的位置</p>
<p>找到根据这个 state 进行渲染的所有组件 -&gt; 找到他们的共同所有者组件（在组件层级上高于所有需要该 state 的组件）-&gt; 该共同所有者或者比它层级更高的组件应该拥有该 state -&gt; 如果你找不到一个合适的位置来存放该 state，可以直接创建一个新的组件来存放，并将这一新组件置于高于共同所有者组件层级的位置</p>
</li>
<li><p>添加反向数据流</p>
<p>开始自下而上调 callback 传递数据上去给 state 所在</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ce">
    <link itemprop="mainEntityOfPage" href="https://hayahayao.github.io/2020/04/04/Git%E5%8E%9F%E7%90%86&%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hayahayao">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="さおりのBlog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/04/04/Git%E5%8E%9F%E7%90%86&%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Git原理&常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-04-04 18:59:00" itemprop="dateCreated datePublished" datetime="2020-04-04T18:59:00+08:00">2020-04-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-23 01:33:23" itemprop="dateModified" datetime="2023-08-23T01:33:23+08:00">2023-08-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>git 维护三棵树：</p>
<ul>
<li>working directory：工作目录</li>
<li>stage(index)：缓存</li>
<li>history：commit 历史</li>
</ul>
<p>可以参考这个 <a target="_blank" rel="noopener" href="https://github.com/geeeeeeeeek/git-recipes/wiki/4.1-%E5%9B%BE%E8%A7%A3-Git-%E5%91%BD%E4%BB%A4">图解 Git 命令</a></p>
<h2 id="获取-创建项目"><a href="#获取-创建项目" class="headerlink" title="获取&#x2F;创建项目"></a>获取&#x2F;创建项目</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="literal">--bare</span> &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<p>初始化一个裸的（没有工作目录的） Git 仓库，中央仓库应该总是用 –bare 标记创建，因为向非裸仓库推送分支有可能会覆盖已有的代码变动。将 bare 看作是将仓库标记为储存设施而不是开发环境，中央仓库是裸仓库，开发者的本地仓库是非裸仓库。</p>
<h3 id="clone"><a href="#clone" class="headerlink" title="clone"></a>clone</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将位于 &lt;repo&gt; 的仓库克隆到本地机器</span></span><br><span class="line">git clone &lt;repo&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将位于 &lt;repo&gt; 的仓库克隆到本地机器上的 &lt;directory&gt; 目录</span></span><br><span class="line">git clone &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure>

<h4 id="LF-CRLF"><a href="#LF-CRLF" class="headerlink" title="LF CRLF"></a>LF CRLF</h4><p>clone 下来的东西报 lf crlf 的错误，是由于 git clone 的时候自动进行了转换，可以如下设置关闭</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config <span class="literal">--global</span> core.autocrlf false</span><br></pre></td></tr></table></figure>

<h3 id="submodule"><a href="#submodule" class="headerlink" title="submodule"></a>submodule</h3><p>可以通过 git submodule 配置子模块，git 会在父级目录中用 .gitmodules 文件记录</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="config"><a href="#config" class="headerlink" title="config"></a>config</h3><p>常见配置</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &lt;name&gt;</span><br><span class="line">git config <span class="literal">--global</span> user.name &lt;name&gt;</span><br><span class="line">git config <span class="literal">--global</span> user.email &lt;email&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为 git 命令创建一个快捷方式（别名）</span></span><br><span class="line">git config <span class="literal">--global</span> alias.&lt;alias<span class="literal">-name</span>&gt; &lt;git<span class="literal">-command</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义当前机器所有用户使用命令时用到的文本编辑器</span></span><br><span class="line">git config <span class="literal">--system</span> core.editor &lt;editor&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用文本编辑器打开全局配置文件，手动编辑</span></span><br><span class="line">git config <span class="literal">--global</span> <span class="literal">--edit</span></span><br></pre></td></tr></table></figure>

<p>git 的配置项存储位置：</p>
<ul>
<li>&#x2F;.git&#x2F;config – 特定仓库的设置。</li>
<li>~&#x2F;.gitconfig – 特定用户的设置。这也是 <code>--global</code> 标记的设置项存放的位置。</li>
<li>$(prefix)&#x2F;etc&#x2F;gitconfig – 系统层面的设置。</li>
</ul>
<h4 id="忽略特定文件"><a href="#忽略特定文件" class="headerlink" title="忽略特定文件"></a>忽略特定文件</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">update-index</span> <span class="literal">--assume-unchanged</span> PATH</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想撤销这个操作</span></span><br><span class="line">git <span class="built_in">update-index</span> <span class="literal">--no-assume-unchanged</span> PATH</span><br></pre></td></tr></table></figure>

<h2 id="基本快照操作"><a href="#基本快照操作" class="headerlink" title="基本快照操作"></a>基本快照操作</h2><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><p>将工作目录中的变化添加到缓冲区，缓存更改</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add &lt;directory&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式的缓存</span></span><br><span class="line">git add <span class="literal">-p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以控制那些行被加进去</span></span><br><span class="line">git add <span class="literal">--edit</span></span><br></pre></td></tr></table></figure>

<h3 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h3><p>将缓存的快照提交到项目历史</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行文本编辑器，等待输入提交信息</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 &lt;message&gt; 作为提交信息</span></span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;&lt;message&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动添加缓冲和提交，除了 new files</span></span><br><span class="line">git commit <span class="literal">-a</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并 index 和上一次 commit 提交，且不修改 commit message</span></span><br><span class="line"><span class="comment"># amend 会修改 commit 的 hash 值，无论有没有实际文件变化/message 变化</span></span><br><span class="line">git commit <span class="literal">--amend</span> <span class="literal">--no-edit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制设定 commit 日期</span></span><br><span class="line">git commit <span class="literal">--date</span>=&lt;date&gt;</span><br></pre></td></tr></table></figure>

<h3 id="status"><a href="#status" class="headerlink" title="status"></a>status</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>文件状态：</p>
<ul>
<li>modified, to be commited：已缓存</li>
<li>not staged for commit：未缓存</li>
<li>untracked：未追踪</li>
</ul>
<h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># = rm 且默认（-f）add file</span></span><br><span class="line"><span class="comment"># 从 index 和本地都删除</span></span><br><span class="line"><span class="comment"># 下次 commit 时会修改 git 仓库</span></span><br><span class="line">git <span class="built_in">rm</span> &lt;file&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 index 里面删除文件，但本地的文件还保留</span></span><br><span class="line"><span class="comment"># 即“停止跟踪”这些文件</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="literal">--cached</span> file</span><br></pre></td></tr></table></figure>

<h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名一个文件</span></span><br><span class="line">git <span class="built_in">mv</span> &lt;source&gt; &lt;destination&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移动一个文件</span></span><br><span class="line">git <span class="built_in">mv</span> &lt;source&gt; &lt;destination directory&gt;</span><br></pre></td></tr></table></figure>

<p>通过 git mv 去移动相当于自动 add 到 stage 中，不用手动 git add</p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><p>改变 HEAD 指向的 commit，并有选择地变动 working directory 和 index；也用来在从  commit 历史中复制文件到 index，而不动 working directory</p>
<p>reset 可以理解为重设，而 revert 是撤销：reset 移除掉后面所有的 commit，如果想恢复只能自己重新提交，这个重设是永远的，改了就再也找不回来了，所以要小心，最好只用在本地修改</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前 HEAD 指向 &lt;commit&gt;</span></span><br><span class="line"><span class="comment"># 有几种常用 mode</span></span><br><span class="line"><span class="comment"># --soft：不改变 index 和 working tree</span></span><br><span class="line"><span class="comment"># --mixed：改变 index，不改变 working tree</span></span><br><span class="line"><span class="comment"># --hard：改变 index 和 working tree</span></span><br><span class="line">git reset [&lt;<span class="type">mode</span>&gt;] [&lt;<span class="type">commit</span>&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有给出 commit 版本则默认 HEAD</span></span><br><span class="line"><span class="comment"># mode 不为 soft 的时候都是改变 index 但不改变 working tree</span></span><br><span class="line">git reset</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 tree-ish(commit) 中的 file 复制到当前 index</span></span><br><span class="line">git reset &lt;tree<span class="literal">-ish</span>&gt; <span class="literal">--</span> &lt;files&gt;</span><br></pre></td></tr></table></figure>

<h3 id="restore"><a href="#restore" class="headerlink" title="restore"></a>restore</h3><p>可以通过 git reflog 查看日志，找到 reset 前的 commit，然后用 restore 将 working directory 恢复（但是commit 不会恢复，要重新提交）</p>
<h2 id="分支与合并"><a href="#分支与合并" class="headerlink" title="分支与合并"></a>分支与合并</h2><h3 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出（本地）仓库中所有分支</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程分支</span></span><br><span class="line">git branch <span class="literal">-r</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个名为 branch 的分支（但不会自动切换到那个分支）</span></span><br><span class="line">git branch &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定分支</span></span><br><span class="line"><span class="comment"># 安全操作，Git 会阻止你删除未合并更改的分支</span></span><br><span class="line">git branch <span class="literal">-d</span> &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定分支，即使包含未合并更改</span></span><br><span class="line">git branch <span class="literal">-D</span> &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前分支命名为 branch</span></span><br><span class="line">git branch <span class="literal">-m</span> &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>Git 的分支实际上是指向 commit 的指针，代表了一系列 commit 的顶端，而不是 commit 的容器。分支历史通过提交之间的关系来推断</p>
<p>所以 Git 的合并其实是将两个独立的 commit 历史连接起来，而不是基于文件的操作</p>
<p>因为分支本质是个指针，所以创建&#x2F;删除分支都不会影响到仓库历史</p>
<p>删除分支时 Git 会检查这个分支是否已经被合并，如果还没被合并就删除，那就相当于丢失了这段开发线的入口（指针），所以 Git 会做出错误提示</p>
<h3 id="checkout"><a href="#checkout" class="headerlink" title="checkout"></a>checkout</h3><p>从 commit history 或 index 中拷贝文件到 working directory；或切换分支</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从指定的 commit 中拷贝文件到 working directory</span></span><br><span class="line"><span class="comment"># 如果不指定 tree-ish 则会从 index 中拷贝缓存的内容到 working directory</span></span><br><span class="line">git checkout &lt;tree<span class="literal">-ish</span>&gt; <span class="literal">--</span> &lt;files&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># HEAD 移动到 branch</span></span><br><span class="line"><span class="comment"># index 和 working directory 会和 HEAD 对应的 commit 节点一致</span></span><br><span class="line"><span class="comment"># 新 commit 节点中所有文件都会被复制到 index 和 working directory 中</span></span><br><span class="line"><span class="comment"># 只存在于老的 commit 节点中的文件会被删除</span></span><br><span class="line"><span class="comment"># 不属于两者的文件会被忽略，不受影响</span></span><br><span class="line">git checkout &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不指定文件名/分支名，而是一个标签/远程分支/SHA-1值，就会得到一个匿名分支</span></span><br><span class="line"><span class="comment"># 称作 detached HEAD（分离的 HEAD）</span></span><br><span class="line"><span class="comment"># 分离状态：提交操作可以正常进行，但是不会更新任何已命名的分支（其实是在更新匿名分支）</span></span><br><span class="line"><span class="comment"># 此后一旦切换到别的分支，那么这个提交节点因为不会被引用掉，所以就被丢弃了</span></span><br><span class="line"><span class="comment"># 如果想要保存这个状态，可以通过 checkout -b name 创建一个新的有名字的分支</span></span><br></pre></td></tr></table></figure>

<h4 id="项目中可能出现的情况"><a href="#项目中可能出现的情况" class="headerlink" title="项目中可能出现的情况"></a>项目中可能出现的情况</h4><p>由于常用的<code>npm run dev</code> 一般是增量编译配置，所以有时候在一个分支编译完 checkout 到另一个分支，但 &#x2F;dist 里的东西由于被 ignore 所以还保留着原分支的一些信息，最好 checkout 之后 rm &#x2F;dist 再重新编译</p>
<h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定分支并入当前分支</span></span><br><span class="line">git merge &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将制定分支并入当前分支</span></span><br><span class="line"><span class="comment"># 但总是生成一个合并提交（即使是快速向前合并）</span></span><br><span class="line">git merge <span class="literal">--no-ff</span> &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>当前分支会被更新，但目标分支完全不受影响</p>
<p>合并算法：</p>
<ul>
<li>快速向前合并：当当前分支顶端到目标分支路径是线性时，Git 只需要将当期分支顶端（快速向前地）移动到目标分支顶端，即可整合两个分支的历史，而不需要“真正”合并分支。在效果上合并了历史，因为目标分支上的 commit 现在在当前分支可以访问到</li>
<li>三路合并：使用一个专门的 commit 来合并两个分支的历史（Git 实际上使用三个 commit 来生成它，分别是两个分支顶端和它们共同的祖先）</li>
</ul>
<p>通常用快速向前合并搭配 rebase 来合并微小的功能或者修复 bug，使用三路合并来整合长期运行的功能</p>
<h4 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h4><p>手动解决：merge 发现错误 -&gt; 自己修复 -&gt; git add -&gt; git commit 生成合并提交</p>
<h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 meassage</span></span><br><span class="line">git stash push <span class="literal">-m</span> &lt;message&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 弹出一个存储的 state</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 类似于 stack peek，查看但不弹出</span></span><br><span class="line">git stash apply</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出现有的 stash</span></span><br><span class="line">git stash list</span><br></pre></td></tr></table></figure>

<p>把现在的 working directory 和 index 存起来，但是不 commit 到 history 以免污染历史</p>
<h4 id="找回不小心-pop-drop-掉的-stash"><a href="#找回不小心-pop-drop-掉的-stash" class="headerlink" title="找回不小心 pop&#x2F;drop 掉的 stash"></a>找回不小心 pop&#x2F;drop 掉的 stash</h4><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/89332/how-to-recover-a-dropped-stash-in-git#34666995">出处</a></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> gitk <span class="literal">--all</span> <span class="variable">$</span>(git fsck <span class="literal">--no-reflog</span> | <span class="built_in">Select-String</span> <span class="string">&quot;(dangling commit )(.*)</span></span><br><span class="line"><span class="string">&quot;</span> | %&#123; <span class="variable">$_</span>.Line.Split(<span class="string">&#x27; &#x27;</span>)[<span class="number">2</span>] &#125;)</span><br></pre></td></tr></table></figure>

<p>之后会打开一个 GUI 界面，在里面找到你丢失掉的那个 commit 值之后 <code>git stash apply &lt;commit&gt;</code> 即可</p>
<h3 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h3><p>通常在发布版本时打一个 tag，tag 会记录版本的 commi 号，方便后期回溯</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出已有 tag</span></span><br><span class="line">git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建 tag</span></span><br><span class="line">git tag &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带备注的 tag</span></span><br><span class="line">git tag <span class="literal">-a</span> &lt;tagname&gt; <span class="literal">-m</span> &lt;msg&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给指定的某个 commit 加 tag</span></span><br><span class="line">git tag <span class="literal">-a</span> &lt;tagname&gt; &lt;commit&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 tag 详细信息</span></span><br><span class="line">git show &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 tag 同步到远程服务器</span></span><br><span class="line">git push origin &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换 tag</span></span><br><span class="line"><span class="comment"># 当 branch 和 tagname 重名时候可以指定 tags/tagname</span></span><br><span class="line">git checkout &lt;tagname&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 tag</span></span><br><span class="line">git tag <span class="literal">-d</span> &lt;tagname&gt;</span><br></pre></td></tr></table></figure>

<h2 id="分享更新项目"><a href="#分享更新项目" class="headerlink" title="分享更新项目"></a>分享更新项目</h2><h3 id="remote"><a href="#remote" class="headerlink" title="remote"></a>remote</h3><p>管理与其他仓库之间的连接，用书签（别名）的方式去引用其他仓库的 url 连接</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出远程连接列表</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带 url 的列表</span></span><br><span class="line">git remote <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加/删除远程连接</span></span><br><span class="line">git remote add &lt;name&gt; &lt;url&gt;</span><br><span class="line">git remote <span class="built_in">rm</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名</span></span><br><span class="line">git remote rename &lt;old<span class="literal">-name</span>&gt; &lt;<span class="built_in">new-name</span>&gt;</span><br></pre></td></tr></table></figure>

<p>git clone 时，自动创建了一个名为 origin 的远程连接，指向被克隆的 repo（基本上都是中央仓库）</p>
<p>http 或 ssh 协议</p>
<h3 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h3><p>将远程仓库的提交拉到本地仓库，拉下来的提交储存为远程分支，而不是我们一直用的普通的本地分支</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拉取仓库中的所有分支</span></span><br><span class="line">git fetch &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只拉取指定分支</span></span><br><span class="line">git fetch &lt;remote&gt; &lt;branch&gt;</span><br></pre></td></tr></table></figure>

<p>查看拉下来的远程分支时，会像 checkout 一样处于分离 HEAD 状态（基本上可以视作只读）</p>
<p>如果接受远程分支包含的更改，可以用 <code>git merge</code> 将它并入本地分支</p>
<h3 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h3><p>&#x3D; fetch + merge</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># = fetch + merge origin/.</span></span><br><span class="line">git pull &lt;remote&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与上一个命令相同，但使用 rebase 合并远程分支与本地分支，而不是 merge</span></span><br><span class="line"><span class="comment"># rebase 可以用来保证项目的线性历史，</span></span><br><span class="line">git pull <span class="literal">--rebase</span> &lt;remote&gt;</span><br></pre></td></tr></table></figure>

<h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>将提交导出到远程分支</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将指定的分支推送到 remote 上</span></span><br><span class="line"><span class="comment"># 如果导致目标仓库非快速向前合并时，git 不允许 push</span></span><br><span class="line"><span class="comment"># 非快速向前合并指的就是要真正发生 merge 的情况（即已经分叉）</span></span><br><span class="line">git push &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使会导致非快速向前合并也强制推送</span></span><br><span class="line">git push &lt;remote&gt; <span class="literal">--force</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送所有本地分支</span></span><br><span class="line">git push &lt;remote&gt; <span class="literal">--all</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有本地标签推送到远程仓库</span></span><br><span class="line"><span class="comment"># 上面的写法都不会自动推送标签</span></span><br><span class="line">git push &lt;remote&gt; <span class="literal">--tags</span></span><br></pre></td></tr></table></figure>

<p>push 其实相当于在远程仓库内部运行 <code>git merge</code></p>
<p>只应该推送到那些用 –bare 初始化的仓库（裸仓库，没有工作目录）。因为 push 会弄乱远程分支结构，所以永远不要推送到其他开发者的仓库</p>
<h4 id="开发标准做法"><a href="#开发标准做法" class="headerlink" title="开发标准做法"></a>开发标准做法</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master <span class="comment"># 参考 checkout 中的解释，注意并不会造成工作丢失！</span></span><br><span class="line">git fetch origin master <span class="comment"># 确保本地 master 和中央仓库一致</span></span><br><span class="line">git rebase <span class="literal">-i</span> origin/master <span class="comment"># 交互式 rebase，清理 commit</span></span><br><span class="line">git push origin master <span class="comment"># 确定本地 master 是最新的，能够快速向前合并</span></span><br></pre></td></tr></table></figure>

<h2 id="审查比较"><a href="#审查比较" class="headerlink" title="审查比较"></a>审查比较</h2><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><h4 id="行号"><a href="#行号" class="headerlink" title="行号"></a>行号</h4><p>git diff 不能直接得到行号信息，而是会给出一个 <a target="_blank" rel="noopener" href="http://www.gnu.org/software/diffutils/manual/html_node/Detailed-Unified.html#Detailed-Unified">unified-diff format</a> 格式的东西：</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">@</span><span class="selector-tag">@</span> <span class="literal">-start</span>,count +<span class="built_in">start</span>,count <span class="selector-tag">@</span><span class="selector-tag">@</span></span><br></pre></td></tr></table></figure>

<p><code>-</code> 标记的代表原状态的信息，<code>+</code> 标记的代表现状态的信息</p>
<p><code>start</code> 代表原状态&#x2F;现状态的开始行号，<code>count</code> 代表从 start 开始有多少行被修改了</p>
<p>实际数起来是这样的（例子来自 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24455377/git-diff-with-line-numbers-git-log-with-line-numbers">stack overflow 的这个回答</a>）</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">diff</span> <span class="literal">--git</span> a/osx/.gitconfig b/osx/.gitconfig</span><br><span class="line">index <span class="number">4</span>fd8f04..fcd220c <span class="number">100644</span></span><br><span class="line"><span class="literal">---</span> a/osx/.gitconfig</span><br><span class="line">+++ b/osx/.gitconfig</span><br><span class="line"><span class="selector-tag">@</span><span class="selector-tag">@</span> <span class="literal">-11</span>,<span class="number">7</span> +<span class="number">11</span>,<span class="number">7</span> <span class="selector-tag">@</span><span class="selector-tag">@</span> &lt;== HERE!</span><br><span class="line"> [<span class="type">color</span> <span class="string">&quot;branch&quot;</span>]</span><br><span class="line">        upstream = cyan</span><br><span class="line"> [<span class="type">color</span> <span class="string">&quot;diff&quot;</span>]</span><br><span class="line">-       meta = yellow</span><br><span class="line">+       meta = cyan</span><br><span class="line">        plain = white dim</span><br><span class="line">        old = red bold</span><br><span class="line">        new = green bold</span><br></pre></td></tr></table></figure>

<p>这里的 11 代表下面显示的这些代码从第 11 行开始，包括 7 行，所以原文件中的行号其实是这样的</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>  [<span class="type">color</span> <span class="string">&quot;branch&quot;</span>]</span><br><span class="line"><span class="number">12</span>         upstream = cyan</span><br><span class="line"><span class="number">13</span>  [<span class="type">color</span> <span class="string">&quot;diff&quot;</span>]</span><br><span class="line"><span class="number">14</span> -       meta = yellow</span><br><span class="line"><span class="number">14</span> +       meta = cyan</span><br><span class="line"><span class="number">15</span>         plain = white dim</span><br><span class="line"><span class="number">16</span>         old = red bold</span><br><span class="line"><span class="number">17</span>         new = green bold</span><br></pre></td></tr></table></figure>

<p>所以实际被修改的是第 14 行。</p>
<h2 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h2><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>将分支移到一个新的基 commit 的过程</p>
<p>rebase 这个“基”，指的是三路合并时的那个基 commit</p>
<p>从内容的角度看，rebase 只不过是将分支从一个 commit 移到了另一个；但是从内部机制来看， Git 是通过在选定的基上创建新 commit 来完成这件事的，事实上重写了项目历史</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前分支 rebase 到 base</span></span><br><span class="line"><span class="comment"># base 可以是任何类型的 commit 引用：ID、分支名、标签、或是 HEAD 的相对引用</span></span><br><span class="line">git rebase &lt;base&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式的 rebase</span></span><br><span class="line"><span class="comment"># 在过程中可以修改每个 commit，控制它们怎样转移到新的基上去，也可以对它们进行排序</span></span><br><span class="line">git rebase <span class="literal">-i</span> &lt;base&gt;</span><br></pre></td></tr></table></figure>

<p>rebase 的主要目的是为了保持一个线性的项目历史</p>
<p>将自己的 feature 分支整合进 master 分支，有两个选择：</p>
<ul>
<li>直接 merge，会产生一个三路合并和一个合并提交</li>
<li>先 rebase 到 master HEAD 再 merge，产生一个快速向前的合并以及完美的线性历史</li>
</ul>
<p>rebase 是将上游更改合并进本地仓库的通常方法，“我想将我的更改建立在其他人的进展之上”的感觉</p>
<p>本质上是线性化的自动的 cherry-pick</p>
<h3 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个撤销了 commit 引入的修改的新提交，然后应用到当前分支</span></span><br><span class="line">git revert &lt;commit&gt;</span><br></pre></td></tr></table></figure>

<p>应该用在想要在项目历史中移除一整个提交（通常是因为这个提交造成 bug）的时候</p>
<p>被撤销的提交依然在项目历史中，git revert 在后面增加了一个提交来撤销修改，而不是删除它</p>
<h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><p>“复制一个 commit 节点并在当前分支做一次完全一样的新提交</p>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><h3 id="blame"><a href="#blame" class="headerlink" title="blame"></a>blame</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame <span class="literal">--</span> &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>显示该文件的修改，以及每个修改的作者</p>
<h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>打印出符合指定 pattern 的行数</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git grep &lt;pattern&gt; <span class="literal">--</span> &lt;files&gt;</span><br></pre></td></tr></table></figure>

<h3 id="bisect"><a href="#bisect" class="headerlink" title="bisect"></a>bisect</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git bisect &lt;subcommand&gt; &lt;options&gt;</span><br></pre></td></tr></table></figure>

<p>用二分查找的方式找出 bug 来自于哪个 commit，具体见 <a target="_blank" rel="noopener" href="https://git-scm.com/docs/git-bisect">官方文档</a></p>
<h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="reflog"><a href="#reflog" class="headerlink" title="reflog"></a>reflog</h3><p>查看日志</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hayahayao</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hayahayao</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
